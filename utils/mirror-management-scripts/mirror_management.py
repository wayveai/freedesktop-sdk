'''Supplies the test functions needed by check_mirrors.py. Intended to run as
part of the regular CI jobs for the freedesktop-sdk project. Reads through a
manifest of buildstream element sources (generated by the url_manifest plugin),
and then perform various tests to check that aliases are correctly defined, and
that the download mirrors are correctly set up.

See the help information in check_mirrors.py for more information.'''

import functools
import json
import re
import subprocess
import tempfile as tf
import sys
import gitlab

GITLAB_URL = 'https://gitlab.com'
MIRROR_GROUP_ID = '3487254'
MIRROR_GROUP_URL = 'https://gitlab.com/freedesktop-sdk/mirrors'
TAR_PROJECT_ID = '15704256'
TAR_PROJECT_URL = 'https://gitlab.com/freedesktop-sdk/mirrors/tarball-lfs-mirror.git'
TAR_URL_PREFIX = 'https://gitlab.com/freedesktop-sdk/mirrors/tarball-lfs-mirror/raw/master/'

IS_TTY = sys.stdout.isatty()

def test_sources(manifest, test_dict, is_verbose, ignore_dict):
    '''iterates through the manifest and applies the relevant test to each
    source, ignoring any sources specified in the ignore dict. Prints the list
    of problems to stdout (if 'is_verbose' is true), and returns the problem
    list.'''


    ignore_elements = []
    ignore_source_urls = []
    test_name = test_dict['name']
    if ignore_dict:
        ignore_elements += ignore_dict['all_tests']['ignore elements'].copy()
        ignore_elements += ignore_dict[test_name]['ignore elements'].copy()
        ignore_source_urls += ignore_dict['all_tests']['ignore source_urls'].copy()
        ignore_source_urls += ignore_dict[test_name]['ignore source_urls'].copy()

    problem_list = []

    for element in manifest:
        if element['element'] in ignore_elements:
            continue
        for source in element['sources']:
            if source['source_url'] in ignore_source_urls:
                continue
            problem = test_dict['func'](source)
            if problem:
                problem_source = {
                    'element': element['element'],
                    'problem': problem,
                }
                problem_source.update(source)
                problem_list.append(problem_source)

    if is_verbose:
        print(test_dict['verbose_text'])
        if problem_list:
            print(json.dumps(problem_list, indent=2))
        else:
            print("   {No problems identified}")

    return problem_list

ALIAS_REGEX = re.compile('(^[^:]*):(?!/)(.*)')
# a sequence of non-colon characters (the alias),
# then a colon (the separator)
# ... which isn't followed by a slash (to rule out "https://")
# then the rest of the url

def alias_test(source_dict):
    '''Tests whether a source url was defined using a recognized alias
    Returns a string describing the problem, or 'None' if all is well.'''
    if source_dict['alias'] is None:
        match = ALIAS_REGEX.match(source_dict['raw_url'])
        return "unrecognized alias" if match else "no alias used"
    return None

ALIAS_TEST_DICT = {
    'name': 'alias_test', 'func': alias_test,
    'verbose_text': "Identifying sources that don't use a recognized alias:"
}

def mirror_defined_test(source_dict):
    '''Tests whether the alias has a mirror defined for it.
    Returns a string describing the problem, or 'None' if all is well.'''
    if source_dict['mirror_url'] is None  and source_dict['alias'] is not None:
        # anything where the alias is 'None', should be caught by alias_test(),
        # not by this test.
        return 'no mirror url defined for alias'
    return None

MIRROR_DEFINED_TEST_DICT = {
    'name': 'mirror_defined_test', 'func': mirror_defined_test,
    'verbose_text': "Identifying sources where no mirror_url is defined:"
}

@functools.cache
def glab_mirror_dict():
    mapping = {}
    mapping.update(get_repo_list_from_gitlab())
    mapping.update(get_file_mirror_list_from_gitlab())
    return mapping

def mirror_exists_test(source_dict):
    '''Accesses a list of all the mirrors we've created in our gitlab group,
    and tests whether the current source is mirrored there.
    Returns a string describing the problem, or 'None' if all is well.'''

    mirror_url = source_dict['mirror_url']
    if mirror_url and mirror_url.endswith('.git'):
        mirror_url = mirror_url[:-4]
    if mirror_url not in glab_mirror_dict():
        return "Download mirror doesn't seem to have been created"
    return None

MIRROR_EXISTS_TEST_DICT = {
    'name': 'mirror_exists_test', 'func': mirror_exists_test,
    'verbose_text': "Identifying sources where no download mirror exists:"
}

def mirror_commit_exists_test(source_dict):
    '''Tests if the required commit exists, in one of our mirror repositories.
    Returns a string describing the problem, or 'None' if all is well.'''
    if source_dict['mirror_url']:
        # There's no point running this test if there's no mirror url defined
        # There's a different test designed to catch those errors
        if source_dict['kind'] in ['git', 'git_tag']:
            if not test_commit_exists(source_dict['mirror_url'], source_dict['ref']):
                return "Commit doesn't seem to exist in mirror repository"
    return None

MIRROR_COMMIT_EXISTS_TEST_DICT = {
    'name': 'mirror_commit_exists_test', 'func': mirror_commit_exists_test,
    'verbose_text': "Identifying sources that won't be able to download properly from the download"
                    + "-mirror repository, because the appropriate commit doesn't seem to exist."
}

def get_repo_list_from_gitlab():
    '''Collects a list of our git repository mirrors, from our Gitlab group'''
    glb = gitlab.Gitlab(GITLAB_URL)
    print("Contacting Gitlab instance")
    mirror_group = glb.groups.get(MIRROR_GROUP_ID)
    print(f"Getting list of git mirrors from {mirror_group.web_url}")
    projects = mirror_group.projects.list(all=True, include_subgroups=True)

    output_dict = {}
    for project in projects:
        project_dict = {
            'name':             project.name,
            'mirror-id':        project.id,
            'bmirror-type':     'git repo',
        }
        output_dict[project.web_url] = project_dict
    return output_dict

def get_file_mirror_list_from_gitlab():
    '''Collects a list of the files mirrored in our LFS mirror repository'''
    glb = gitlab.Gitlab(GITLAB_URL)
    print("Contacting Gitlab instance")
    tar_project = glb.projects.get(TAR_PROJECT_ID)
    print(f"Getting list of file mirrors from {tar_project.http_url_to_repo}")
    tar_list = tar_project.repository_tree(recursive=True, all=True)
    output_dict = {}
    for tar_file in tar_list:
        if tar_file['name'] in ['.gitattributes', 'README.md']:
            continue
        if tar_file['type'] == 'tree':
            continue
        https_url = TAR_URL_PREFIX + tar_file['path']
        tar_dict = {
            'name':         tar_file['name'],
            'mirror-id':    tar_file['id'],
            'mirror-type': 'file download',
        }
        output_dict[https_url] = tar_dict
    return output_dict

def call_command(command, cwd_dir):
    '''Invokes subprocess.call with some standard arguments prefilled'''
    return subprocess.call(
        command, shell=True, cwd=cwd_dir, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
    )

def clear_line():
    '''Clears the current line of stdout, and moves cursor back to the left of
    the screen. Used after sys.stdout.write()'''
    if IS_TTY:
        sys.stdout.write('\u001b[2K\u001b[1000D') # Clear line & reset cursor back to the left
        sys.stdout.flush()

INIT_COMMAND = 'git init'
REMOTE_COMMAND = 'git remote add origin "{}"'
LS_REMOTE_COMMAND = 'GIT_TERMINAL_PROMPT=0 git ls-remote origin | cut -f1 | grep "{}"'
FETCH_ORIGIN_COMMAND = 'GIT_TERMINAL_PROMPT=0 git fetch origin'
CHECK_LOG_COMMAND = 'git log -1 "{}"'

def test_commit_exists(repo_url, commit_ref):
    '''Tests if a remote repository contains a given commit, given an url and a
    ref. Assumes the ref will either consist entirely of the sha1 string, or
    else be in the form {tag_name}{other characters}g{sha1 string}.
    Anything up to a 'g' character will be removed, to leave the sha1'''
    sha1 = re.search("(.*g)?(.*)", commit_ref).group(2)
    if IS_TTY:
        info_string = f"Checking commit exists at {repo_url}"
        sys.stdout.write(info_string)
        sys.stdout.flush()
    with tf.TemporaryDirectory() as tmp_dir:
        call_command(INIT_COMMAND, tmp_dir)
        call_command(REMOTE_COMMAND.format(repo_url), tmp_dir)
        found_in_ls_remote = call_command(LS_REMOTE_COMMAND.format(sha1), tmp_dir)
        if found_in_ls_remote == 0:
            # An exit code of 0 indicates success
            clear_line()
            return True
        call_command(FETCH_ORIGIN_COMMAND, tmp_dir)
        found_by_fetching = call_command(CHECK_LOG_COMMAND.format(sha1), tmp_dir)
        if found_by_fetching == 0:
            # An exit code of 0 indicates success
            clear_line()
            return True

    print("Commit not found")
    return False

def test_ostree_url_exists(repo_url, commit_ref):
    '''Tests if a remote repository contains a given commit, given an url and a
    ref.'''
    info_string = f"Checking ostree commit exists at {repo_url}"
    is_tty = sys.stdout.isatty()
    if is_tty:
        sys.stdout.write(info_string)
        sys.stdout.flush()
    with tf.TemporaryDirectory() as tmp_dir:
        for command in [
                'ostree init --repo=. --mode=archive',
                'ostree remote add origin --no-gpg-verify "' + repo_url + '"',
                'ostree pull origin ' + commit_ref + ' --commit-metadata-only --depth=0'
        ]:
            call_command(command, tmp_dir)
        if call_command('ostree log ' + commit_ref, tmp_dir) == 0:
            clear_line()
            return True
        print("Ostree commit not found")
        return False
