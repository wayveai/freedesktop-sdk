commit 12aebf728fec7b3cc7c203b27f2cf8fd203f81c6
Author: Akira TAGOH <akira@tagoh.org>
Date:   Fri Apr 12 12:03:57 2019 +0000

    Rework Flatpak support
    
    fontconfig relies on font paths to determine cache filename
    and it is used to generate MD5. this means fontconfig
    re-generates caches even if it has same fonts.
    This affects the performance a lot on Flatpak applications
    because they share fonts from host with different
    paths and then re-generating caches at first run.
    
    So we put an UUID into .uuid at a font directory as
    an unique identifier, and generate caches with it instead
    of MD5.  However, this affects the reproducible builds now
    because UUID is randomly generated and it is impossible to predict.
    
    So reverting it and introduce new mechanism to share caches.
    
    fontconfig now has remap-dir element to handle a font
    path as a different path internally. let's see:
    
    <remap-dir as-path="/usr/share/fonts">/run/host/fonts</remap-dir>
    
    When accessing a cache from host, fontconfig considers it is
    a cache for /run/host/fonts and shows patterns to applications
    like that.
    
    So what if having own fonts under /usr/share/fonts?
    To address this, fontconfig extends dir element to give a salt
    to allow generating different cache filename.
    
    <dir salt="unique identifier">/usr/share/fonts</dir>
    
    Then fontconfig generates a cache in the different name
    to what host has.

diff --git a/conf.d/05-reset-dirs-sample.conf b/conf.d/05-reset-dirs-sample.conf
new file mode 100644
index 0000000..80bb6fb
--- /dev/null
+++ b/conf.d/05-reset-dirs-sample.conf
@@ -0,0 +1,9 @@
+<?xml version="1.0"?>
+<!DOCTYPE fontconfig SYSTEM "fonts.dtd">
+<fontconfig>
+  <description>Re-define fonts dirs sample</description>
+
+  <reset-dirs />
+  <dir prefix="xdg">fonts</dir>
+
+</fontconfig>
diff --git a/conf.d/Makefile.am b/conf.d/Makefile.am
index ff03fb2..d0f3f26 100644
--- a/conf.d/Makefile.am
+++ b/conf.d/Makefile.am
@@ -52,6 +52,7 @@ config_DATA = $(DOC_FILES)
 
 templatedir = $(TEMPLATEDIR)
 template_DATA =				\
+	05-reset-dirs-sample.conf	\
 	10-autohint.conf		\
 	10-hinting-full.conf		\
 	10-hinting-medium.conf		\
diff --git a/configure.ac b/configure.ac
index fb8af46..4a864f6 100644
--- a/configure.ac
+++ b/configure.ac
@@ -332,39 +332,6 @@ AM_CONDITIONAL(FREETYPE_PCF_LONG_FAMILY_NAMES, test "x$have_pcf_long_family_name
 LIBS="$fontconfig_save_libs"
 CFLAGS="$fontconfig_save_cflags"
 
-#
-# Check for uuid
-#
-if test "$os_win32" != "yes"; then
-	use_pkgconfig_for_uuid=yes
-	if test -n "${UUID_LIBS}"; then
-		save_UUID_LIBS=$UUID_LIBS
-	fi
-	PKG_CHECK_MODULES([UUID], [uuid],
-			  [use_pkgconfig_for_uuid=yes],
-			  [use_pkgconfig_for_uuid=no])
-	if test "x$use_pkgconfig_for_uuid" = "xno"; then
-		AC_MSG_CHECKING([where uuid functions comes from])
-		AC_TRY_LINK([#include <uuid/uuid.h>],
-			[uuid_t a; uuid_generate(a);],
-			[AC_MSG_RESULT([builtin])
-			 UUID_CFLAGS=""
-			 UUID_LIBS=""
-			],[AC_MSG_ERROR([
-*** uuid is required. install util-linux.
-			])])
-	else
-		if test -z "${save_UUID_LIBS+x}" && test "x${UUID_LIBS}" != "x"; then
-			PKGCONFIG_REQUIRES_PRIVATELY="$PKGCONFIG_REQUIRES_PRIVATELY uuid"
-		fi
-	fi
-else
-	UUID_CFLAGS=""
-	UUID_LIBS=""
-fi
-AC_SUBST(UUID_CFLAGS)
-AC_SUBST(UUID_LIBS)
-
 #
 # Check expat configuration
 #
diff --git a/doc/fccache.fncs b/doc/fccache.fncs
index 972b642..cf79134 100644
--- a/doc/fccache.fncs
+++ b/doc/fccache.fncs
@@ -95,10 +95,7 @@ to <parameter>config</parameter>.
 @TYPE3@		FcConfig *			@ARG3@		config
 @PURPOSE@	Create .uuid file at a directory
 @DESC@
-This is to create .uuid file containing an UUID at a font directory of
-<parameter>dir</parameter>.
-The UUID will be used to identify the font directory and is used to determine
-the cache filename if available.
+This function is deprecated. it doesn't take any effects.
 @SINCE@		2.12.92
 @@
 
diff --git a/doc/fcstring.fncs b/doc/fcstring.fncs
index 0412bbd..d5ec043 100644
--- a/doc/fcstring.fncs
+++ b/doc/fcstring.fncs
@@ -223,6 +223,18 @@ This is just a wrapper around free(3) which helps track memory usage of
 strings within the fontconfig library.
 @@
 
+@RET@		FcChar8 *
+@FUNC@		FcStrBuildFilename
+@TYPE1@		const FcChar8 *			@ARG1@		path
+@TYPE2@		...
+@PURPOSE@	Concatenate strings as a file path
+@DESC@
+Creates a filename from the given elements of strings as file paths
+and concatenate them with the appropriate file separator.
+Arguments must be null-terminated.
+This returns a newly-allocated memory which should be freed when no longer needed.
+@@
+
 @RET@		FcChar8 *
 @FUNC@		FcStrDirname
 @TYPE1@		const FcChar8 *			@ARG1@		file
diff --git a/doc/fontconfig-user.sgml b/doc/fontconfig-user.sgml
index 89df86e..9fbfe94 100644
--- a/doc/fontconfig-user.sgml
+++ b/doc/fontconfig-user.sgml
@@ -310,9 +310,13 @@ following structure:
 This is the top level element for a font configuration and can contain
 <literal>&lt;dir&gt;</literal>, <literal>&lt;cachedir&gt;</literal>, <literal>&lt;include&gt;</literal>, <literal>&lt;match&gt;</literal> and <literal>&lt;alias&gt;</literal> elements in any order.
   </para></refsect2>
-  <refsect2><title><literal>&lt;dir prefix="default"&gt;</literal></title><para>
+  <refsect2><title><literal>&lt;dir prefix="default" salt=""&gt;</literal></title><para>
 This element contains a directory name which will be scanned for font files
-to include in the set of available fonts. If 'prefix' is set to "xdg", the value in the XDG_DATA_HOME environment variable will be added as the path prefix. please see XDG Base Directory Specification for more details.
+to include in the set of available fonts.
+  </para><para>
+If 'prefix' is set to "xdg", the value in the XDG_DATA_HOME environment variable will be added as the path prefix. please see XDG Base Directory Specification for more details.
+  </para><para>
+'salt' property affects to determine cache filename. this is useful for example when having different fonts sets on same path at container and share fonts from host on different font path.
   </para></refsect2>
   <refsect2><title><literal>&lt;cachedir prefix="default"&gt;</literal></title><para>
 This element contains a directory name that is supposed to be stored or read
@@ -346,6 +350,19 @@ drawn as blanks on the screen.  Within the <literal>&lt;blank&gt;</literal> elem
 Unicode characters which is supposed to be blank in an <literal>&lt;int&gt;</literal> element.
 Characters outside of this set which are drawn as blank will be elided from
 the set of characters supported by the font.
+  </para></refsect2>
+  <refsect2><title><literal>&lt;remap-dir prefix="default" as-path="" salt=""&lt;</literal></title><para>
+This element contains a directory name where will be mapped
+as the path 'as-path' in cached information.
+This is useful if the directory name is an alias
+(via a bind mount or symlink) to another directory in the system for
+which cached font information is likely to exist.
+  </para><para>
+'salt' property affects to determine cache filename as same as <literal>&lt;dir&gt;</literal> element.
+  </para></refsect2>
+  <refsect2><title><literal>&lt;reset-dirs /&gt;</literal></title><para>
+This element removes all of fonts directories where added by <literal>&lt;dir&gt;</literal> elements.
+This is useful to override fonts directories from system to own fonts directories only.
   </para></refsect2>
   <refsect2><title><literal>&lt;rescan&gt;</literal></title><para>
 The <literal>&lt;rescan&gt;</literal> element holds an <literal>&lt;int&gt;</literal> element which indicates the default
diff --git a/fc-cache/fc-cache.c b/fc-cache/fc-cache.c
index 87e3020..7c58f40 100644
--- a/fc-cache/fc-cache.c
+++ b/fc-cache/fc-cache.c
@@ -191,7 +191,6 @@ scanDirs (FcStrList *list, FcConfig *config, FcBool force, FcBool really_force,
 	if (really_force)
 	{
 	    FcDirCacheUnlink (dir, config);
-	    FcDirCacheCreateUUID ((FcChar8 *) dir, FcTrue, config);
 	}
 
 	cache = NULL;
@@ -392,6 +391,17 @@ main (int argc, char **argv)
 	return 1;
     }
 
+    if (verbose)
+    {
+	const FcChar8 *dir;
+
+	printf ("Font directories:\n");
+	while ((dir = FcStrListNext (list)))
+	{
+	    printf ("\t%s\n", dir);
+	}
+	FcStrListFirst(list);
+    }
     changed = 0;
     ret = scanDirs (list, config, force, really_force, verbose, error_on_no_fonts, &changed);
     FcStrListDone (list);
diff --git a/fontconfig/fontconfig.h b/fontconfig/fontconfig.h
index bac1dda..af870d0 100644
--- a/fontconfig/fontconfig.h
+++ b/fontconfig/fontconfig.h
@@ -1076,6 +1076,10 @@ FcUtf16Len (const FcChar8   *string,
 	    int		    *nchar,
 	    int		    *wchar);
 
+FcPublic FcChar8 *
+FcStrBuildFilename (const FcChar8 *path,
+		    ...);
+
 FcPublic FcChar8 *
 FcStrDirname (const FcChar8 *file);
 
diff --git a/fonts.dtd b/fonts.dtd
index 479f2c0..fede9a7 100644
--- a/fonts.dtd
+++ b/fonts.dtd
@@ -4,6 +4,8 @@
 		      cachedir |
 		      include | 
 		      config |
+		      remap-dir |
+		      reset-dirs |
 		      selectfont |
 		      match | 
 		      alias)* >
@@ -94,6 +96,21 @@
 	</edit>
     </match>
 -->
+
+<!--
+    Map a font path as the path "as-path"
+-->
+<!ELEMENT remap-dir (#PCDATA)>
+<!ATTLIST remap-dir
+          as-path   CDATA                       #REQUIRED
+          prefix    (default|xdg|relative|cwd)  "default"
+	  xml:space (default|preserve)          "preserve">
+
+<!--
+    Reset the list of fonts directories
+-->
+<!ELEMENT reset-dirs >
+
 <!--
     Periodically rescan the font configuration and
     directories to synch internal state with filesystem
diff --git a/src/Makefile.am b/src/Makefile.am
index 7b414df..35e820d 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -77,7 +77,6 @@ AM_CPPFLAGS = 						\
 	$(ICONV_CFLAGS)					\
 	$(LIBXML2_CFLAGS)				\
 	$(EXPAT_CFLAGS)					\
-	$(UUID_CFLAGS)					\
 	$(WARN_CFLAGS)					\
 	-DFC_CACHEDIR='"$(FC_CACHEDIR)"'                \
 	-DFONTCONFIG_PATH='"$(BASECONFIGDIR)"'		\
@@ -167,7 +166,7 @@ lib_LTLIBRARIES = libfontconfig.la
 libfontconfig_la_LDFLAGS =			\
 	-version-info @LIBT_VERSION_INFO@ -no-undefined $(export_symbols)
 
-libfontconfig_la_LIBADD = $(ICONV_LIBS) $(FREETYPE_LIBS) $(LIBXML2_LIBS) $(EXPAT_LIBS) $(UUID_LIBS) $(LTLIBINTL)
+libfontconfig_la_LIBADD = $(ICONV_LIBS) $(FREETYPE_LIBS) $(LIBXML2_LIBS) $(EXPAT_LIBS) $(LTLIBINTL)
 
 libfontconfig_la_DEPENDENCIES = $(fontconfig_def_dependency)
 
diff --git a/src/fccache.c b/src/fccache.c
index 2b60401..3071104 100644
--- a/src/fccache.c
+++ b/src/fccache.c
@@ -38,8 +38,6 @@
 #endif
 #if defined(_WIN32)
 #include <sys/locking.h>
-#else
-#include <uuid/uuid.h>
 #endif
 
 #ifndef O_BINARY
@@ -51,178 +49,55 @@ FcDirCacheCreateUUID (FcChar8  *dir,
 		      FcBool    force,
 		      FcConfig *config)
 {
-    const FcChar8 *sysroot = FcConfigGetSysRoot (config);
-    FcChar8 *target;
-    FcBool ret = FcTrue;
-#ifndef _WIN32
-    FcChar8 *uuidname;
-
-    if (sysroot)
-	target = FcStrBuildFilename (sysroot, dir, NULL);
-    else
-	target = FcStrdup (dir);
-    uuidname = FcStrBuildFilename (target, ".uuid", NULL);
-
-    if (!uuidname)
-    {
-	FcStrFree (target);
-	return FcFalse;
-    }
-
-    if (force || access ((const char *) uuidname, F_OK) < 0)
-    {
-	FcAtomic *atomic;
-	int fd;
-	uuid_t uuid;
-	char out[37];
-	FcBool (* hash_add) (FcHashTable *, void*, void*);
-	struct stat statb;
-	struct timeval times[2];
-
-	if (FcStat (target, &statb) != 0)
-	{
-	    ret = FcFalse;
-	    goto bail1;
-	}
-	atomic = FcAtomicCreate (uuidname);
-	if (!atomic)
-	{
-	    ret = FcFalse;
-	    goto bail1;
-	}
-	if (!FcAtomicLock (atomic))
-	{
-	    ret = FcFalse;
-	    goto bail2;
-	}
-	fd = FcOpen ((char *)FcAtomicNewFile (atomic), O_RDWR | O_CREAT, 0644);
-	if (fd == -1)
-	{
-	    ret = FcFalse;
-	    goto bail3;
-	}
-	uuid_generate_random (uuid);
-	if (force)
-	    hash_add = FcHashTableReplace;
-	else
-	    hash_add = FcHashTableAdd;
-	if (!hash_add (config->uuid_table, target, uuid))
-	{
-	    ret = FcFalse;
-	    FcAtomicDeleteNew (atomic);
-	    close (fd);
-	    goto bail3;
-	}
-	uuid_unparse (uuid, out);
-	if (FcDebug () & FC_DBG_CACHE)
-	    printf ("FcDirCacheCreateUUID %s: %s\n", uuidname, out);
-	write (fd, out, strlen (out));
-	close (fd);
-	FcAtomicReplaceOrig (atomic);
-    bail3:
-	FcAtomicUnlock (atomic);
-    bail2:
-	FcAtomicDestroy (atomic);
-
-	if (ret)
-	{
-	    /* revert mtime of the directory */
-	    times[0].tv_sec = statb.st_atime;
-	    times[1].tv_sec = statb.st_mtime;
-#ifdef HAVE_STRUCT_STAT_ST_MTIM
-	    times[0].tv_usec = statb.st_atim.tv_nsec / 1000;
-	    times[1].tv_usec = statb.st_mtim.tv_nsec / 1000;
-#else
-	    times[0].tv_usec = 0;
-	    times[1].tv_usec = 0;
-#endif
-	    if (utimes ((const  char *) target, times) != 0)
-	    {
-		fprintf (stderr, "Unable to revert mtime: %s\n", target);
-	    }
-	}
-    }
-bail1:
-    FcStrFree (uuidname);
-    FcStrFree (target);
-#endif
-
-    return ret;
+    return FcTrue;
 }
 
 FcBool
 FcDirCacheDeleteUUID (const FcChar8  *dir,
 		      FcConfig       *config)
 {
-    const FcChar8 *sysroot = FcConfigGetSysRoot (config);
-    FcChar8 *target;
     FcBool ret = FcTrue;
-
-    if (sysroot)
-	target = FcStrBuildFilename (sysroot, dir, ".uuid", NULL);
-    else
-	target = FcStrBuildFilename (dir, ".uuid", NULL);
-
-    ret = unlink ((char *) target) == 0;
-    FcHashTableRemove (config->uuid_table, target);
-    FcStrFree(target);
-
-    return ret;
-}
-
 #ifndef _WIN32
-static void
-FcDirCacheReadUUID (FcChar8  *dir,
-		    FcConfig *config)
-{
-    void *u;
-    uuid_t uuid;
     const FcChar8 *sysroot = FcConfigGetSysRoot (config);
-    FcChar8 *target;
+    FcChar8 *target, *d;
+    struct stat statb;
+    struct timeval times[2];
 
     if (sysroot)
-	target = FcStrBuildFilename (sysroot, dir, NULL);
+	d = FcStrBuildFilename (sysroot, dir, NULL);
     else
-	target = FcStrdup (dir);
-
-    if (!FcHashTableFind (config->uuid_table, target, &u))
+	d = FcStrBuildFilename (dir, NULL);
+    if (FcStat (d, &statb) != 0)
     {
-	FcChar8 *uuidname = FcStrBuildFilename (target, ".uuid", NULL);
-	int fd;
-
-	if ((fd = FcOpen ((char *) uuidname, O_RDONLY)) >= 0)
-	{
-	    char suuid[37];
-	    ssize_t len;
-
-	    memset (suuid, 0, sizeof (suuid));
-	    len = read (fd, suuid, 36);
-	    if (len != -1)
-	    {
-		suuid[len] = 0;
-		memset (uuid, 0, sizeof (uuid));
-		if (uuid_parse (suuid, uuid) == 0)
-		{
-		    if (FcDebug () & FC_DBG_CACHE)
-			printf ("FcDirCacheReadUUID %s -> %s\n", uuidname, suuid);
-		    FcHashTableAdd (config->uuid_table, target, uuid);
-		}
-	    }
-	    close (fd);
-	}
-	else
+	ret = FcFalse;
+	goto bail;
+    }
+    target = FcStrBuildFilename (d, ".uuid", NULL);
+    ret = unlink ((char *) target) == 0;
+    if (ret)
+    {
+	times[0].tv_sec = statb.st_atime;
+	times[1].tv_sec = statb.st_mtime;
+#ifdef HAVE_STRUCT_STAT_ST_MTIM
+	times[0].tv_usec = statb.st_atim.tv_nsec / 1000;
+	times[1].tv_usec = statb.st_mtim.tv_nsec / 1000;
+#else
+	times[0].tv_usec = 0;
+	times[1].tv_usec = 0;
+#endif
+	if (utimes ((const char *) d, times) != 0)
 	{
-	    if (FcDebug () & FC_DBG_CACHE)
-		printf ("FcDirCacheReadUUID Unable to read %s\n", uuidname);
+	    fprintf (stderr, "Unable to revert mtime: %s\n", d);
 	}
-	FcStrFree (uuidname);
     }
-    else
-	FcHashUuidFree (u);
     FcStrFree (target);
-}
+bail:
+    FcStrFree (d);
 #endif
 
+    return ret;
+}
+
 struct MD5Context {
         FcChar32 buf[4];
         FcChar32 bits[2];
@@ -273,18 +148,49 @@ static const char bin2hex[] = { '0', '1', '2', '3',
 				'c', 'd', 'e', 'f' };
 
 static FcChar8 *
-FcDirCacheBasenameMD5 (const FcChar8 *dir, FcChar8 cache_base[CACHEBASE_LEN])
+FcDirCacheBasenameMD5 (FcConfig *config, const FcChar8 *dir, FcChar8 cache_base[CACHEBASE_LEN])
 {
+    FcChar8		*mapped_dir = NULL;
     unsigned char 	hash[16];
-    FcChar8		*hex_hash;
+    FcChar8		*hex_hash, *key = NULL;
     int			cnt;
     struct MD5Context 	ctx;
-
+    const FcChar8	*salt, *orig_dir = NULL;
+
+    salt = FcConfigMapSalt (config, dir);
+    /* Obtain a path where "dir" is mapped to.
+     * In case:
+     * <remap-dir as-path="/usr/share/fonts">/run/host/fonts</remap-dir>
+     *
+     * FcConfigMapFontPath (config, "/run/host/fonts") will returns "/usr/share/fonts".
+     */
+    mapped_dir = FcConfigMapFontPath(config, dir);
+    if (mapped_dir)
+    {
+	orig_dir = dir;
+	dir = mapped_dir;
+    }
+    if (salt)
+    {
+	size_t dl = strlen ((const char *) dir);
+	size_t sl = strlen ((const char *) salt);
+
+	key = (FcChar8 *) malloc (dl + sl + 1);
+	memcpy (key, dir, dl);
+	memcpy (key + dl, salt, sl + 1);
+	key[dl + sl] = 0;
+	if (!orig_dir)
+		orig_dir = dir;
+	dir = key;
+    }
     MD5Init (&ctx);
     MD5Update (&ctx, (const unsigned char *)dir, strlen ((const char *) dir));
 
     MD5Final (hash, &ctx);
 
+    if (key)
+	FcStrFree (key);
+
     cache_base[0] = '/';
     hex_hash = cache_base + 1;
     for (cnt = 0; cnt < 16; ++cnt)
@@ -294,32 +200,58 @@ FcDirCacheBasenameMD5 (const FcChar8 *dir, FcChar8 cache_base[CACHEBASE_LEN])
     }
     hex_hash[2*cnt] = 0;
     strcat ((char *) cache_base, "-" FC_ARCHITECTURE FC_CACHE_SUFFIX);
+    if (FcDebug() & FC_DBG_CACHE)
+    {
+	printf ("cache: %s (dir: %s%s%s%s%s%s)\n", cache_base, orig_dir ? orig_dir : dir, mapped_dir ? " (mapped to " : "", mapped_dir ? (char *)mapped_dir : "", mapped_dir ? ")" : "", salt ? ", salt: " : "", salt ? (char *)salt : "");
+    }
+
+    if (mapped_dir)
+	FcStrFree(mapped_dir);
 
     return cache_base;
 }
 
 #ifndef _WIN32
 static FcChar8 *
-FcDirCacheBasenameUUID (const FcChar8 *dir, FcChar8 cache_base[CACHEBASE_LEN], FcConfig *config)
+FcDirCacheBasenameUUID (FcConfig *config, const FcChar8 *dir, FcChar8 cache_base[CACHEBASE_LEN])
 {
-    void *u;
-    FcChar8 *target;
+    FcChar8 *target, *fuuid;
     const FcChar8 *sysroot = FcConfigGetSysRoot (config);
+    int fd;
 
+    /* We don't need to apply remapping here. because .uuid was created at that very directory
+     * to determine the cache name no matter where it was mapped to.
+     */
+    cache_base[0] = 0;
     if (sysroot)
 	target = FcStrBuildFilename (sysroot, dir, NULL);
     else
 	target = FcStrdup (dir);
-    if (FcHashTableFind (config->uuid_table, target, &u))
+    fuuid = FcStrBuildFilename (target, ".uuid", NULL);
+    if ((fd = FcOpen ((char *) fuuid, O_RDONLY)) != -1)
     {
-	uuid_unparse (u, (char *) cache_base);
+	char suuid[37];
+	ssize_t len;
+
+	memset (suuid, 0, sizeof (suuid));
+	len = read (fd, suuid, 36);
+	suuid[36] = 0;
+	close (fd);
+	if (len < 0)
+	    goto bail;
+	cache_base[0] = '/';
+	strcpy ((char *)&cache_base[1], suuid);
 	strcat ((char *) cache_base, "-" FC_ARCHITECTURE FC_CACHE_SUFFIX);
-	FcHashUuidFree (u);
-	FcStrFree (target);
-	return cache_base;
+	if (FcDebug () & FC_DBG_CACHE)
+	{
+	    printf ("cache fallbacks to: %s (dir: %s)\n", cache_base, dir);
+	}
     }
+bail:
+    FcStrFree (fuuid);
     FcStrFree (target);
-    return NULL;
+
+    return cache_base;
 }
 #endif
 
@@ -328,14 +260,17 @@ FcDirCacheUnlink (const FcChar8 *dir, FcConfig *config)
 {
     FcChar8	*cache_hashed = NULL;
     FcChar8	cache_base[CACHEBASE_LEN];
+#ifndef _WIN32
+    FcChar8     uuid_cache_base[CACHEBASE_LEN];
+#endif
     FcStrList	*list;
     FcChar8	*cache_dir;
     const FcChar8 *sysroot = FcConfigGetSysRoot (config);
 
+    FcDirCacheBasenameMD5 (config, dir, cache_base);
 #ifndef _WIN32
-    if (!FcDirCacheBasenameUUID (dir, cache_base, config))
+    FcDirCacheBasenameUUID (config, dir, uuid_cache_base);
 #endif
-	FcDirCacheBasenameMD5 (dir, cache_base);
 
     list = FcStrListCreate (config->cacheDirs);
     if (!list)
@@ -350,10 +285,23 @@ FcDirCacheUnlink (const FcChar8 *dir, FcConfig *config)
         if (!cache_hashed)
 	    break;
 	(void) unlink ((char *) cache_hashed);
-	FcDirCacheDeleteUUID (dir, config);
 	FcStrFree (cache_hashed);
+#ifndef _WIN32
+	if (uuid_cache_base[0] != 0)
+	{
+	    if (sysroot)
+		cache_hashed = FcStrBuildFilename (sysroot, cache_dir, uuid_cache_base, NULL);
+	    else
+		cache_hashed = FcStrBuildFilename (cache_dir, uuid_cache_base, NULL);
+	    if (!cache_hashed)
+		break;
+	    (void) unlink ((char *) cache_hashed);
+	    FcStrFree (cache_hashed);
+	}
+#endif
     }
     FcStrListDone (list);
+    FcDirCacheDeleteUUID (dir, config);
     /* return FcFalse if something went wrong */
     if (cache_dir)
 	return FcFalse;
@@ -412,10 +360,7 @@ FcDirCacheProcess (FcConfig *config, const FcChar8 *dir,
     }
     FcStrFree (d);
 
-#ifndef _WIN32
-    if (!FcDirCacheBasenameUUID (dir, cache_base, config))
-#endif
-	FcDirCacheBasenameMD5 (dir, cache_base);
+    FcDirCacheBasenameMD5 (config, dir, cache_base);
 
     list = FcStrListCreate (config->cacheDirs);
     if (!list)
@@ -424,7 +369,11 @@ FcDirCacheProcess (FcConfig *config, const FcChar8 *dir,
     while ((cache_dir = FcStrListNext (list)))
     {
         FcChar8	*cache_hashed;
+#ifndef _WIN32
+	FcBool retried = FcFalse;
 
+    retry:
+#endif
 	if (sysroot)
 	    cache_hashed = FcStrBuildFilename (sysroot, cache_dir, cache_base, NULL);
 	else
@@ -444,6 +393,18 @@ FcDirCacheProcess (FcConfig *config, const FcChar8 *dir,
 		break;
 	    }
 	}
+#ifndef _WIN32
+	else if (!retried)
+	{
+	    retried = FcTrue;
+	    FcDirCacheBasenameUUID (config, dir, cache_base);
+	    if (cache_base[0] != 0)
+	    {
+		FcStrFree (cache_hashed);
+		goto retry;
+	    }
+	}
+#endif
     	FcStrFree (cache_hashed);
     }
     FcStrListDone (list);
@@ -1040,9 +1001,6 @@ FcDirCacheLoad (const FcChar8 *dir, FcConfig *config, FcChar8 **cache_file)
 {
     FcCache *cache = NULL;
 
-#ifndef _WIN32
-    FcDirCacheReadUUID ((FcChar8 *) dir, config);
-#endif
     if (!FcDirCacheProcess (config, dir,
 			    FcDirCacheMapHelper,
 			    &cache, cache_file))
@@ -1346,10 +1304,7 @@ FcDirCacheWrite (FcCache *cache, FcConfig *config)
     if (!cache_dir)
 	return FcFalse;
 
-#ifndef _WIN32
-    if (!FcDirCacheBasenameUUID (dir, cache_base, config))
-#endif
-	FcDirCacheBasenameMD5 (dir, cache_base);
+    FcDirCacheBasenameMD5 (config, dir, cache_base);
     cache_hashed = FcStrBuildFilename (cache_dir, cache_base, NULL);
     FcStrFree (cache_dir);
     if (!cache_hashed)
@@ -1546,10 +1501,7 @@ FcDirCacheLock (const FcChar8 *dir,
     const FcChar8 *sysroot = FcConfigGetSysRoot (config);
     int fd = -1;
 
-#ifndef _WIN32
-    if (!FcDirCacheBasenameUUID (dir, cache_base, config))
-#endif
-	FcDirCacheBasenameMD5 (dir, cache_base);
+    FcDirCacheBasenameMD5 (config, dir, cache_base);
     list = FcStrListCreate (config->cacheDirs);
     if (!list)
 	return -1;
diff --git a/src/fccfg.c b/src/fccfg.c
index d7c48e8..965417c 100644
--- a/src/fccfg.c
+++ b/src/fccfg.c
@@ -52,18 +52,6 @@ retry:
     return config;
 }
 
-static FcChar32
-FcHashAsStrIgnoreCase (const void *data)
-{
-    return FcStrHashIgnoreCase (data);
-}
-
-static int
-FcCompareAsStr (const void *v1, const void *v2)
-{
-    return FcStrCmp (v1, v2);
-}
-
 static void
 FcDestroyAsRule (void *data)
 {
@@ -76,12 +64,6 @@ FcDestroyAsRuleSet (void *data)
     FcRuleSetDestroy (data);
 }
 
-static void
-FcDestroyAsStr (void *data)
-{
-    FcStrFree (data);
-}
-
 FcBool
 FcConfigInit (void)
 {
@@ -96,6 +78,29 @@ FcConfigFini (void)
 	FcConfigDestroy (cfg);
 }
 
+static FcChar8 *
+FcConfigRealPath(const FcChar8 *path)
+{
+    char	resolved_name[PATH_MAX+1];
+    char	*resolved_ret;
+
+    if (!path)
+	return NULL;
+
+#ifndef _WIN32
+    resolved_ret = realpath((const char *) path, resolved_name);
+#else
+    if (GetFullPathNameA ((LPCSTR) path, PATH_MAX, resolved_name, NULL) == 0)
+    {
+        fprintf (stderr, "Fontconfig warning: GetFullPathNameA failed.\n");
+        return NULL;
+    }
+    resolved_ret = resolved_name;
+#endif
+    if (resolved_ret)
+	path = (FcChar8 *) resolved_ret;
+    return FcStrCopyFilename(path);
+}
 
 FcConfig *
 FcConfigCreate (void)
@@ -113,6 +118,10 @@ FcConfigCreate (void)
     if (!config->configDirs)
 	goto bail1;
 
+    config->configMapDirs = FcStrSetCreate();
+    if (!config->configMapDirs)
+	goto bail1_5;
+
     config->configFiles = FcStrSetCreate ();
     if (!config->configFiles)
 	goto bail2;
@@ -159,7 +168,7 @@ FcConfigCreate (void)
 
     config->expr_pool = NULL;
 
-    config->sysRoot = NULL;
+    config->sysRoot = FcConfigRealPath((const FcChar8 *) getenv("FONTCONFIG_SYSROOT"));
 
     config->rulesetList = FcPtrListCreate (FcDestroyAsRuleSet);
     if (!config->rulesetList)
@@ -168,13 +177,6 @@ FcConfigCreate (void)
     if (!config->availConfigFiles)
 	goto bail10;
 
-    config->uuid_table = FcHashTableCreate (FcHashAsStrIgnoreCase,
-					    FcCompareAsStr,
-					    FcHashStrCopy,
-					    FcHashUuidCopy,
-					    FcDestroyAsStr,
-					    FcHashUuidFree);
-
     FcRefInit (&config->ref, 1);
 
     return config;
@@ -199,6 +201,8 @@ bail4:
 bail3:
     FcStrSetDestroy (config->configFiles);
 bail2:
+    FcStrSetDestroy (config->configMapDirs);
+bail1_5:
     FcStrSetDestroy (config->configDirs);
 bail1:
     free (config);
@@ -310,6 +314,7 @@ FcConfigDestroy (FcConfig *config)
     (void) fc_atomic_ptr_cmpexch (&_fcConfig, config, NULL);
 
     FcStrSetDestroy (config->configDirs);
+    FcStrSetDestroy (config->configMapDirs);
     FcStrSetDestroy (config->fontDirs);
     FcStrSetDestroy (config->cacheDirs);
     FcStrSetDestroy (config->configFiles);
@@ -336,8 +341,6 @@ FcConfigDestroy (FcConfig *config)
     if (config->sysRoot)
 	FcStrFree (config->sysRoot);
 
-    FcHashTableDestroy (config->uuid_table);
-
     free (config);
 }
 
@@ -545,9 +548,32 @@ FcConfigGetConfigDirs (FcConfig   *config)
 
 FcBool
 FcConfigAddFontDir (FcConfig	    *config,
-		    const FcChar8   *d)
+		    const FcChar8   *d,
+		    const FcChar8   *m,
+		    const FcChar8   *salt)
+{
+    if (FcDebug() & FC_DBG_CACHE)
+    {
+	if (m)
+	{
+	    printf ("%s -> %s%s%s%s\n", d, m, salt ? " (salt: " : "", salt ? (const char *)salt : "", salt ? ")" : "");
+	}
+	else if (salt)
+	{
+	    printf ("%s%s%s%s\n", d, salt ? " (salt: " : "", salt ? (const char *)salt : "", salt ? ")" : "");
+	}
+    }
+    return FcStrSetAddFilenamePairWithSalt (config->fontDirs, d, m, salt);
+}
+
+FcBool
+FcConfigResetFontDirs (FcConfig *config)
 {
-    return FcStrSetAddFilename (config->fontDirs, d);
+    if (FcDebug() & FC_DBG_CACHE)
+    {
+	printf ("Reset font directories!\n");
+    }
+    return FcStrSetDeleteAll (config->fontDirs);
 }
 
 FcStrList *
@@ -562,6 +588,80 @@ FcConfigGetFontDirs (FcConfig	*config)
     return FcStrListCreate (config->fontDirs);
 }
 
+static FcBool
+FcConfigPathStartsWith(const FcChar8	*path,
+		       const FcChar8	*start)
+{
+    int len = strlen((char *) start);
+
+    if (strncmp((char *) path, (char *) start, len) != 0)
+	return FcFalse;
+
+    switch (path[len]) {
+    case '\0':
+    case FC_DIR_SEPARATOR:
+	return FcTrue;
+    default:
+	return FcFalse;
+    }
+}
+
+FcChar8 *
+FcConfigMapFontPath(FcConfig		*config,
+		    const FcChar8	*path)
+{
+    FcStrList	*list;
+    FcChar8	*dir;
+    const FcChar8 *map, *rpath;
+    FcChar8     *retval;
+
+    list = FcConfigGetFontDirs(config);
+    if (!list)
+	return 0;
+    while ((dir = FcStrListNext(list)))
+	if (FcConfigPathStartsWith(path, dir))
+	    break;
+    FcStrListDone(list);
+    if (!dir)
+	return 0;
+    map = FcStrTripleSecond(dir);
+    if (!map)
+	return 0;
+    rpath = path + strlen ((char *) dir);
+    while (*rpath == '/')
+	rpath++;
+    retval = FcStrBuildFilename(map, rpath, NULL);
+    if (retval)
+    {
+	size_t len = strlen ((const char *) retval);
+	while (len > 0 && retval[len-1] == '/')
+	    len--;
+	/* trim the last slash */
+	retval[len] = 0;
+    }
+    return retval;
+}
+
+const FcChar8 *
+FcConfigMapSalt (FcConfig      *config,
+		 const FcChar8 *path)
+{
+    FcStrList *list;
+    FcChar8 *dir;
+
+    list = FcConfigGetFontDirs (config);
+    if (!list)
+	return NULL;
+    while ((dir = FcStrListNext (list)))
+	if (FcConfigPathStartsWith (path, dir))
+	    break;
+    FcStrListDone (list);
+    if (!dir)
+	return NULL;
+
+    return FcStrTripleThird (dir);
+}
+
 FcBool
 FcConfigAddCacheDir (FcConfig	    *config,
 		     const FcChar8  *d)
@@ -2460,11 +2560,7 @@ FcConfigGetSysRoot (const FcConfig *config)
 	if (!config)
 	    return NULL;
     }
-
-    if (config->sysRoot)
-        return config->sysRoot;
-
-    return (FcChar8 *) getenv ("FONTCONFIG_SYSROOT");
+    return config->sysRoot;
 }
 
 void
@@ -2493,7 +2589,7 @@ FcConfigSetSysRoot (FcConfig      *config,
 
     if (sysroot)
     {
-	s = FcStrCopyFilename (sysroot);
+	s = FcConfigRealPath(sysroot);
 	if (!s)
 	    return;
     }
diff --git a/src/fcdir.c b/src/fcdir.c
index 93f220c..7d7b23c 100644
--- a/src/fcdir.c
+++ b/src/fcdir.c
@@ -413,7 +413,6 @@ FcDirCacheRead (const FcChar8 *dir, FcBool force, FcConfig *config)
 {
     FcCache		*cache = NULL;
 
-    FcDirCacheCreateUUID ((FcChar8 *) dir, FcFalse, config);
     /* Try to use existing cache file */
     if (!force)
 	cache = FcDirCacheLoad (dir, config, NULL);
@@ -421,13 +420,6 @@ FcDirCacheRead (const FcChar8 *dir, FcBool force, FcConfig *config)
     /* Not using existing cache file, construct new cache */
     if (!cache)
 	cache = FcDirCacheScan (dir, config);
-    if (cache)
-    {
-	FcFontSet *fs = FcCacheSet (cache);
-
-	if (cache->dirs_count == 0 && (!fs || fs->nfont == 0))
-	    FcDirCacheDeleteUUID (dir, config);
-    }
 
     return cache;
 }
diff --git a/src/fchash.c b/src/fchash.c
index 2f06f1a..e91c72f 100644
--- a/src/fchash.c
+++ b/src/fchash.c
@@ -20,9 +20,6 @@
  * PERFORMANCE OF THIS SOFTWARE.
  */
 #include "fcint.h"
-#ifndef _WIN32
-#include <uuid/uuid.h>
-#endif
 
 #define FC_HASH_SIZE 227
 
@@ -52,23 +49,6 @@ FcHashStrCopy (const void  *src,
     return *dest != NULL;
 }
 
-FcBool
-FcHashUuidCopy (const void  *src,
-		void       **dest)
-{
-#ifndef _WIN32
-    *dest = malloc (sizeof (uuid_t));
-    uuid_copy (*dest, src);
-#endif
-    return FcTrue;
-}
-
-void
-FcHashUuidFree (void *data)
-{
-    free (data);
-}
-
 FcHashTable *
 FcHashTableCreate (FcHashFunc    hash_func,
 		   FcCompareFunc compare_func,
diff --git a/src/fcint.h b/src/fcint.h
index de78cd8..9ae00be 100644
--- a/src/fcint.h
+++ b/src/fcint.h
@@ -509,6 +509,7 @@ struct _FcConfig {
      * and those directives may occur in any order
      */
     FcStrSet	*configDirs;	    /* directories to scan for fonts */
+    FcStrSet	*configMapDirs;	    /* mapped names to generate cache entries */
     /*
      * List of directories containing fonts,
      * built by recursively scanning the set
@@ -565,7 +566,6 @@ struct _FcConfig {
     FcChar8     *sysRoot;	    /* override the system root directory */
     FcStrSet	*availConfigFiles;  /* config files available */
     FcPtrList	*rulesetList;	    /* List of rulesets being installed */
-    FcHashTable *uuid_table;	    /* UUID table for cachedirs */
 };
 
 typedef struct _FcFileTime {
@@ -659,7 +659,20 @@ FcConfigAddConfigDir (FcConfig	    *config,
 
 FcPrivate FcBool
 FcConfigAddFontDir (FcConfig	    *config,
-		    const FcChar8   *d);
+		    const FcChar8   *d,
+		    const FcChar8   *m,
+		    const FcChar8   *salt);
+
+FcPrivate FcBool
+FcConfigResetFontDirs (FcConfig *config);
+
+FcPrivate FcChar8 *
+FcConfigMapFontPath(FcConfig		*config,
+		    const FcChar8	*path);
+
+FcPrivate const FcChar8 *
+FcConfigMapSalt (FcConfig      *config,
+		 const FcChar8 *path);
 
 FcPrivate FcBool
 FcConfigAddCacheDir (FcConfig	    *config,
@@ -1233,6 +1246,24 @@ FcStrSetAddLangs (FcStrSet *strs, const char *languages);
 FcPrivate void
 FcStrSetSort (FcStrSet * set);
 
+FcPrivate FcBool
+FcStrSetMemberAB (FcStrSet *set, const FcChar8 *a, FcChar8 *b, FcChar8 **ret);
+
+FcPrivate FcBool
+FcStrSetAddTriple (FcStrSet *set, const FcChar8 *a, const FcChar8 *b, const FcChar8 *c);
+
+FcPrivate const FcChar8 *
+FcStrTripleSecond (FcChar8 *s);
+
+FcPrivate const FcChar8 *
+FcStrTripleThird (FcChar8 *str);
+
+FcPrivate FcBool
+FcStrSetAddFilenamePairWithSalt (FcStrSet *strs, const FcChar8 *d, const FcChar8 *m, const FcChar8 *salt);
+
+FcPrivate FcBool
+FcStrSetDeleteAll (FcStrSet *set);
+
 FcPrivate void
 FcStrBufInit (FcStrBuf *buf, FcChar8 *init, int size);
 
@@ -1282,10 +1313,6 @@ FcStrUsesHome (const FcChar8 *s);
 FcPrivate FcBool
 FcStrIsAbsoluteFilename (const FcChar8 *s);
 
-FcPrivate FcChar8 *
-FcStrBuildFilename (const FcChar8 *path,
-		    ...);
-
 FcPrivate FcChar8 *
 FcStrLastSlash (const FcChar8  *path);
 
diff --git a/src/fcstr.c b/src/fcstr.c
index 4247c85..cdebe98 100644
--- a/src/fcstr.c
+++ b/src/fcstr.c
@@ -36,6 +36,32 @@ FcStrCopy (const FcChar8 *s)
     return FcStrdup (s);
 }
 
+static FcChar8 *
+FcStrMakeTriple (const FcChar8 *s1, const FcChar8 *s2, const FcChar8 *s3)
+{
+    int	    s1l = s1 ? strlen ((char *) s1) : 0;
+    int	    s2l = s2 ? strlen ((char *) s2) : 0;
+    int     s3l = s3 ? strlen ((char *) s3) : 0;
+    int	    l = s1l + 1 + s2l + 1 + s3l + 1;
+    FcChar8 *s = malloc (l);
+
+    if (!s)
+	return 0;
+    if (s1)
+	memcpy (s, s1, s1l + 1);
+    else
+	s[0] = '\0';
+    if (s2)
+	memcpy (s + s1l + 1, s2, s2l + 1);
+    else
+	s[s1l + 1] = '\0';
+    if (s3)
+	memcpy (s + s1l + 1 + s2l + 1, s3, s3l + 1);
+    else
+	s[s1l + 1 + s2l + 1] = '\0';
+    return s;
+}
+
 FcChar8 *
 FcStrPlus (const FcChar8 *s1, const FcChar8 *s2)
 {
@@ -1207,6 +1233,58 @@ FcStrSetMember (FcStrSet *set, const FcChar8 *s)
     return FcFalse;
 }
 
+static int
+fc_strcmp_r (const FcChar8 *s1, const FcChar8 *s2, const FcChar8 **ret)
+{
+    FcChar8 c1, c2;
+
+    if (s1 == s2)
+    {
+	if (ret)
+	    *ret = NULL;
+	return 0;
+    }
+    for (;;)
+    {
+	if (s1)
+	    c1 = *s1++;
+	else
+	    c1 = 0;
+	if (s2)
+	    c2 = *s2++;
+	else
+	    c2 = 0;
+	if (!c1 || c1 != c2)
+	    break;
+    }
+    if (ret)
+	*ret = s1;
+    return (int) c1  - (int) c2;
+}
+
+FcBool
+FcStrSetMemberAB (FcStrSet *set, const FcChar8 *a, FcChar8 *b, FcChar8 **ret)
+{
+    int i;
+    const FcChar8 *s = NULL;
+
+    for (i = 0; i < set->num; i++)
+    {
+	if (!fc_strcmp_r (set->strs[i], a, &s) && s)
+	{
+	    if (!fc_strcmp_r (s, b, NULL))
+	    {
+		if (ret)
+		    *ret = set->strs[i];
+		return FcTrue;
+	    }
+	}
+    }
+    if (ret)
+	*ret = NULL;
+    return FcFalse;
+}
+
 FcBool
 FcStrSetEqual (FcStrSet *sa, FcStrSet *sb)
 {
@@ -1233,6 +1311,41 @@ FcStrSetAdd (FcStrSet *set, const FcChar8 *s)
     return FcTrue;
 }
 
+FcBool
+FcStrSetAddTriple (FcStrSet *set, const FcChar8 *a, const FcChar8 *b, const FcChar8 *c)
+{
+    FcChar8 *new = FcStrMakeTriple (a, b, c);
+    if (!new)
+	return FcFalse;
+    if (!_FcStrSetAppend (set, new))
+    {
+	FcStrFree (new);
+	return FcFalse;
+    }
+    return FcTrue;
+}
+
+const FcChar8 *
+FcStrTripleSecond (FcChar8 *str)
+{
+    FcChar8 *second = str + strlen((char *) str) + 1;
+
+    if (*second == '\0')
+	return 0;
+    return second;
+}
+
+const FcChar8 *
+FcStrTripleThird (FcChar8 *str)
+{
+    FcChar8 *second = str + strlen ((char *) str) + 1;
+    FcChar8 *third = second + strlen ((char *) second) + 1;
+
+    if (*third == '\0')
+	return 0;
+    return third;
+}
+
 FcBool
 FcStrSetAddFilename (FcStrSet *set, const FcChar8 *s)
 {
@@ -1247,6 +1360,43 @@ FcStrSetAddFilename (FcStrSet *set, const FcChar8 *s)
     return FcTrue;
 }
 
+FcBool
+FcStrSetAddFilenamePairWithSalt (FcStrSet *set, const FcChar8 *a, const FcChar8 *b, const FcChar8 *salt)
+{
+    FcChar8 *new_a = NULL;
+    FcChar8 *new_b = NULL;
+    FcChar8 *rs = NULL;
+    FcBool  ret;
+
+    if (a)
+    {
+	new_a = FcStrCopyFilename (a);
+	if (!new_a)
+	    return FcFalse;
+    }
+    if (b)
+    {
+	new_b = FcStrCopyFilename(b);
+	if (!new_b)
+	{
+	    if (new_a)
+		FcStrFree(new_a);
+	    return FcFalse;
+	}
+    }
+    /* Override maps with new one if exists */
+    if (FcStrSetMemberAB (set, new_a, new_b, &rs))
+    {
+	FcStrSetDel (set, rs);
+    }
+    ret = FcStrSetAddTriple (set, new_a, new_b, salt);
+    if (new_a)
+	FcStrFree (new_a);
+    if (new_b)
+	FcStrFree (new_b);
+    return ret;
+}
+
 FcBool
 FcStrSetAddLangs (FcStrSet *strs, const char *languages)
 {
@@ -1312,6 +1462,22 @@ FcStrSetDel (FcStrSet *set, const FcChar8 *s)
     return FcFalse;
 }
 
+FcBool
+FcStrSetDeleteAll (FcStrSet *set)
+{
+    int i;
+
+    if (FcRefIsConst (&set->ref))
+	return FcFalse;
+
+    for (i = set->num; i > 0; i--)
+    {
+	FcStrFree (set->strs[i - 1]);
+	set->num--;
+    }
+    return FcTrue;
+}
+
 /* TODO Make public */
 static FcStrSet *
 FcStrSetReference (FcStrSet *set)
diff --git a/src/fcxml.c b/src/fcxml.c
index 7797502..df66810 100644
--- a/src/fcxml.c
+++ b/src/fcxml.c
@@ -358,6 +358,8 @@ typedef enum _FcElement {
     FcElementMatch,
     FcElementAlias,
     FcElementDescription,
+    FcElementRemapDir,
+    FcElementResetDirs,
 	
     FcElementRescan,
 
@@ -421,6 +423,8 @@ static const struct {
     { "match",		FcElementMatch },
     { "alias",		FcElementAlias },
     { "description",	FcElementDescription },
+    { "remap-dir",	FcElementRemapDir },
+    { "reset-dirs",	FcElementResetDirs },
 
     { "rescan",		FcElementRescan },
 
@@ -490,6 +494,19 @@ FcElementMap (const XML_Char *name)
     return FcElementUnknown;
 }
 
+static const char *
+FcElementReverseMap (FcElement e)
+{
+    int i;
+
+    for (i = 0; i < NUM_ELEMENT_MAPS; i++)
+	if (fcElementMap[i].element == e)
+	    return fcElementMap[i].name;
+
+    return NULL;
+}
+
+
 typedef struct _FcPStack {
     struct _FcPStack   *prev;
     FcElement		element;
@@ -1265,6 +1282,111 @@ FcConfigGetAttribute (FcConfigParse *parse, const char *attr)
     return 0;
 }
 
+static FcChar8 *
+_get_real_path_from_prefix(FcConfigParse *parse, const FcChar8 *path, const FcChar8 *prefix)
+{
+#ifdef _WIN32
+    const FcChar8 *data;
+    FcChar8 buffer[1000] = { 0 };
+#endif
+    FcChar8 *parent = NULL, *retval = NULL;
+
+    if (prefix)
+    {
+	if (FcStrCmp (prefix, (const FcChar8 *) "xdg") == 0)
+	{
+	    parent = FcConfigXdgDataHome ();
+	    if (!parent)
+	    {
+		/* Home directory might be disabled */
+		return NULL;
+	    }
+	}
+    }
+#ifndef _WIN32
+    /* For Win32, check this later for dealing with special cases */
+    else
+    {
+	if (!FcStrIsAbsoluteFilename (path) && path[0] != '~')
+	    FcConfigMessage (parse, FcSevereWarning, "Use of ambiguous path in <%s> element. please add prefix=\"cwd\" if current behavior is desired.", FcElementReverseMap (parse->pstack->element));
+    }
+    if (parent)
+    {
+	retval = FcStrBuildFilename (parent, path, NULL);
+    }
+    else
+    {
+	retval = FcStrdup (path);
+    }
+#else
+    if (strcmp ((const char *) path, "CUSTOMFONTDIR") == 0)
+    {
+	FcChar8 *p;
+	data = buffer;
+	if (!GetModuleFileName (NULL, (LPCH) buffer, sizeof (buffer) - 20))
+	{
+	    FcConfigMessage (parse, FcSevereError, "GetModuleFileName failed");
+	    return NULL;
+	}
+	/*
+	 * Must use the multi-byte aware function to search
+	 * for backslash because East Asian double-byte code
+	 * pages have characters with backslash as the second
+	 * byte.
+	 */
+	p = _mbsrchr (data, '\\');
+	if (p) *p = '\0';
+	strcat ((char *) data, "\\fonts");
+    }
+    else if (strcmp ((const char *) path, "APPSHAREFONTDIR") == 0)
+    {
+	FcChar8 *p;
+	data = buffer;
+	if (!GetModuleFileName (NULL, (LPCH) buffer, sizeof (buffer) - 20))
+	{
+	    FcConfigMessage (parse, FcSevereError, "GetModuleFileName failed");
+	    return NULL;
+	}
+	p = _mbsrchr (data, '\\');
+	if (p) *p = '\0';
+	strcat ((char *) data, "\\..\\share\\fonts");
+    }
+    else if (strcmp ((const char *) path, "WINDOWSFONTDIR") == 0)
+    {
+	int rc;
+	data = buffer;
+	rc = pGetSystemWindowsDirectory ((LPSTR) buffer, sizeof (buffer) - 20);
+	if (rc == 0 || rc > sizeof (buffer) - 20)
+	{
+	    FcConfigMessage (parse, FcSevereError, "GetSystemWindowsDirectory failed");
+	    return NULL;
+	}
+	if (data [strlen ((const char *) data) - 1] != '\\')
+	    strcat ((char *) data, "\\");
+	strcat ((char *) data, "fonts");
+    }
+    else
+    {
+	data = path;
+	if (!prefix)
+	{
+	    if (!FcStrIsAbsoluteFilename (path) && path[0] != '~')
+		FcConfigMessage (parse, FcSevereWarning, "Use of ambiguous path in <%s> element. please add prefix=\"cwd\" if current behavior is desired.", FcElementReverseMap (parse->pstack->element));
+	}
+	if (parent)
+	{
+	    retval = FcStrBuildFilename (parent, data, NULL);
+	}
+	else
+	{
+	    retval = FcStrdup (data);
+	}
+    }
+#endif
+
+    return retval;
+}
+
 static void
 FcStartElement(void *userData, const XML_Char *name, const XML_Char **attr)
 {
@@ -1926,6 +2048,57 @@ FcParseDescription (FcConfigParse *parse)
     FcStrFree (desc);
 }
 
+static void
+FcParseRemapDir (FcConfigParse *parse)
+{
+    const FcChar8 *path, *attr, *data, *salt;
+    FcChar8 *prefix = NULL;
+
+    data = FcStrBufDoneStatic (&parse->pstack->str);
+    if (!data)
+    {
+	FcConfigMessage (parse, FcSevereError, "out of memory");
+	return;
+    }
+    if (data[0] == 0)
+    {
+	FcConfigMessage (parse, FcSevereWarning, "empty font directory name for remap ignored");
+	return;
+    }
+    path = FcConfigGetAttribute (parse, "as-path");
+    if (!path)
+    {
+	FcConfigMessage (parse, FcSevereWarning, "Missing as-path in remap-dir");
+	return;
+    }
+    attr = FcConfigGetAttribute (parse, "prefix");
+    salt = FcConfigGetAttribute (parse, "salt");
+    prefix = _get_real_path_from_prefix (parse, data, attr);
+    if (!prefix || prefix[0] == 0)
+    {
+	/* nop */
+    }
+    else if (!parse->scanOnly && (!FcStrUsesHome (prefix) || FcConfigHome ()))
+    {
+	if (!FcConfigAddFontDir (parse->config, prefix, path, salt))
+	    FcConfigMessage (parse, FcSevereError, "out of memory; cannot create remap data for %s as %s", prefix, path);
+    }
+    FcStrBufDestroy (&parse->pstack->str);
+
+    if (prefix)
+	FcStrFree (prefix);
+}
+
+static void
+FcParseResetDirs (FcConfigParse *parse)
+{
+    if (!parse->scanOnly)
+    {
+	if (!FcConfigResetFontDirs (parse->config))
+	    FcConfigMessage (parse, FcSevereError, "Unable to reset fonts dirs");
+    }
+}
+
 static FcExpr *
 FcPopExpr (FcConfigParse *parse)
 {
@@ -2066,104 +2239,34 @@ FcParseUnary (FcConfigParse *parse, FcOp op)
 static void
 FcParseDir (FcConfigParse *parse)
 {
-    const FcChar8 *attr, *data;
-    FcChar8 *prefix = NULL, *p;
-#ifdef _WIN32
-    FcChar8         buffer[1000];
-#endif
+    const FcChar8 *attr, *data, *salt;
+    FcChar8 *prefix = NULL;
 
-    attr = FcConfigGetAttribute (parse, "prefix");
-    if (attr && FcStrCmp (attr, (const FcChar8 *)"xdg") == 0)
-    {
-	prefix = FcConfigXdgDataHome ();
-	/* home directory might be disabled.
-	 * simply ignore this element.
-	 */
-	if (!prefix)
-	    goto bail;
-    }
     data = FcStrBufDoneStatic (&parse->pstack->str);
     if (!data)
     {
 	FcConfigMessage (parse, FcSevereError, "out of memory");
-	data = prefix;
-	goto bail;
-    }
-    if (prefix)
-    {
-	size_t plen = strlen ((const char *)prefix);
-	size_t dlen = strlen ((const char *)data);
-
-	p = realloc (prefix, plen + 1 + dlen + 1);
-	if (!p)
-	{
-	    FcConfigMessage (parse, FcSevereError, "out of memory");
-	    goto bail;
-	}
-	prefix = p;
-	prefix[plen] = FC_DIR_SEPARATOR;
-	memcpy (&prefix[plen + 1], data, dlen);
-	prefix[plen + 1 + dlen] = 0;
-	data = prefix;
-    }
-#ifdef _WIN32
-    if (strcmp ((const char *) data, "CUSTOMFONTDIR") == 0)
-    {
-	FcChar8 *p;
-	data = buffer;
-	if (!GetModuleFileName (NULL, (LPCH) buffer, sizeof (buffer) - 20))
-	{
-	    FcConfigMessage (parse, FcSevereError, "GetModuleFileName failed");
-	    goto bail;
-	}
-	/*
-	 * Must use the multi-byte aware function to search
-	 * for backslash because East Asian double-byte code
-	 * pages have characters with backslash as the second
-	 * byte.
-	 */
-	p = _mbsrchr (data, '\\');
-	if (p) *p = '\0';
-	strcat ((char *) data, "\\fonts");
+	return;
     }
-    else if (strcmp ((const char *) data, "APPSHAREFONTDIR") == 0)
+    if (data[0] == 0)
     {
-	FcChar8 *p;
-	data = buffer;
-	if (!GetModuleFileName (NULL, (LPCH) buffer, sizeof (buffer) - 20))
-	{
-	    FcConfigMessage (parse, FcSevereError, "GetModuleFileName failed");
-	    goto bail;
-	}
-	p = _mbsrchr (data, '\\');
-	if (p) *p = '\0';
-	strcat ((char *) data, "\\..\\share\\fonts");
+	FcConfigMessage (parse, FcSevereWarning, "empty font directory name ignored");
+	return;
     }
-    else if (strcmp ((const char *) data, "WINDOWSFONTDIR") == 0)
+    attr = FcConfigGetAttribute (parse, "prefix");
+    salt = FcConfigGetAttribute (parse, "salt");
+    prefix = _get_real_path_from_prefix (parse, data, attr);
+    if (!prefix || prefix[0] == 0)
     {
-	int rc;
-	data = buffer;
-	rc = pGetSystemWindowsDirectory ((LPSTR) buffer, sizeof (buffer) - 20);
-	if (rc == 0 || rc > sizeof (buffer) - 20)
-	{
-	    FcConfigMessage (parse, FcSevereError, "GetSystemWindowsDirectory failed");
-	    goto bail;
-	}
-	if (data [strlen ((const char *) data) - 1] != '\\')
-	    strcat ((char *) data, "\\");
-	strcat ((char *) data, "fonts");
+	/* nop */
     }
-#endif
-    if (strlen ((char *) data) == 0)
-	FcConfigMessage (parse, FcSevereWarning, "empty font directory name ignored");
-    else if (!parse->scanOnly && (!FcStrUsesHome (data) || FcConfigHome ()))
+    else if (!parse->scanOnly && (!FcStrUsesHome (prefix) || FcConfigHome ()))
     {
-	if (!FcConfigAddFontDir (parse->config, data))
-	    FcConfigMessage (parse, FcSevereError, "out of memory; cannot add directory %s", data);
+	if (!FcConfigAddFontDir (parse->config, prefix, NULL, salt))
+	    FcConfigMessage (parse, FcSevereError, "out of memory; cannot add directory %s", prefix);
     }
     FcStrBufDestroy (&parse->pstack->str);
 
-  bail:
     if (prefix)
 	FcStrFree (prefix);
 }
@@ -2981,6 +3084,12 @@ FcEndElement(void *userData, const XML_Char *name FC_UNUSED)
     case FcElementDescription:
 	FcParseDescription (parse);
 	break;
+    case FcElementRemapDir:
+	FcParseRemapDir (parse);
+	break;
+    case FcElementResetDirs:
+	FcParseResetDirs (parse);
+	break;
 
     case FcElementRescan:
 	FcParseRescan (parse);
diff --git a/test/Makefile.am b/test/Makefile.am
index 79bcede..3068d69 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -74,11 +74,7 @@ endif
 check_PROGRAMS += test-bz106618
 test_bz106618_LDADD = $(top_builddir)/src/libfontconfig.la
 
-check_PROGRAMS += test-hash
-test_hash_CFLAGS = -I$(top_builddir) -I$(top_builddir)/src $(UUID_CFLAGS)
-test_hash_LDADD = $(UUID_LIBS)
-TESTS += test-hash
-
+if !OS_WIN32
 check_PROGRAMS += test-bz106632
 test_bz106632_CFLAGS =					\
 	-I$(top_builddir)				\
@@ -90,6 +86,13 @@ test_bz106632_CFLAGS =					\
 	$(NULL)
 test_bz106632_LDADD = $(top_builddir)/src/libfontconfig.la
 TESTS += test-bz106632
+endif
+
+check_PROGRAMS += test-issue107
+test_issue107_LDADD =					\
+	$(top_builddir)/src/libfontconfig.la		\
+	$(NULL)
+TESTS += test-issue107
 
 EXTRA_DIST=run-test.sh run-test-conf.sh $(TESTDATA) out.expected-long-family-names out.expected-no-long-family-names
 
diff --git a/test/fonts.conf.in b/test/fonts.conf.in
index 95def72..12a0b76 100644
--- a/test/fonts.conf.in
+++ b/test/fonts.conf.in
@@ -1,4 +1,5 @@
 <fontconfig>
+@REMAPDIR@
 <dir>@FONTDIR@</dir>
 <cachedir>@CACHEDIR@</cachedir>
 </fontconfig>
diff --git a/test/run-test-conf.sh b/test/run-test-conf.sh
index 4bcc29c..242b513 100644
--- a/test/run-test-conf.sh
+++ b/test/run-test-conf.sh
@@ -21,7 +21,7 @@
 # DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 # TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 # PERFORMANCE OF THIS SOFTWARE.
-set -eu
+set -e
 
 case "$OSTYPE" in
     msys ) MyPWD=`pwd -W` ;;  # On Msys/MinGW, returns a MS Windows style path.
diff --git a/test/run-test-map.sh b/test/run-test-map.sh
new file mode 100755
index 0000000..869d7b2
--- /dev/null
+++ b/test/run-test-map.sh
@@ -0,0 +1,107 @@
+#!/bin/bash
+# fontconfig/test/run-test-cache-map.sh
+#
+# Copyright Â© 2018 Keith Packard
+#
+# Permission to use, copy, modify, distribute, and sell this software and its
+# documentation for any purpose is hereby granted without fee, provided that
+# the above copyright notice appear in all copies and that both that copyright
+# notice and this permission notice appear in supporting documentation, and
+# that the name of the copyright holders not be used in advertising or
+# publicity pertaining to distribution of the software without specific,
+# written prior permission.  The copyright holders make no representations
+# about the suitability of this software for any purpose.  It is provided "as
+# is" without express or implied warranty.
+#
+# THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+# EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+# TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+# OF THIS SOFTWARE.
+#
+
+case "$OSTYPE" in
+    msys ) MyPWD=`pwd -W` ;;  # On Msys/MinGW, returns a MS Windows style path.
+    *    ) MyPWD=`pwd`    ;;  # On any other platforms, returns a Unix style path.
+esac
+
+TESTDIR=${srcdir-"$MyPWD"}
+BUILDTESTDIR=${builddir-"$MyPWD"}
+
+FONTDIRA="$MyPWD"/fontsa
+FONTDIRB="$MyPWD"/fontsb
+CACHEDIR="$MyPWD"/cache.dir
+EXPECTEDIN=${EXPECTEDIN-"out-map.expected.in"}
+EXPECTEDA="out-map-a.expected"
+EXPECTEDB="out-map-b.expected"
+EXPECTED="out-map.expected"
+
+FCLIST=../fc-list/fc-list$EXEEXT
+FCCACHE=../fc-cache/fc-cache$EXEEXT
+
+which bwrap > /dev/null 2>&1
+if [ $? -eq 0 ]; then
+    BWRAP=`which bwrap`
+fi
+
+FONT1=$TESTDIR/4x6.pcf
+FONT2=$TESTDIR/8x16.pcf
+
+check () {
+  $FCLIST - file family pixelsize | sort > out
+  echo "=" >> out
+  $FCLIST - file family pixelsize | sort >> out
+  echo "=" >> out
+  $FCLIST - file family pixelsize | sort >> out
+  tr -d '\015' <out >out.tmp; mv out.tmp out
+  if cmp out $BUILDTESTDIR/$EXPECTED > /dev/null ; then : ; else
+    echo "*** Test failed: $TEST"
+    echo "*** output is in 'out', expected output in '$EXPECTED'"
+    exit 1
+  fi
+  rm -f out
+}
+
+prep() {
+  rm -rf $CACHEDIR
+  rm -rf $FONTDIRA $FONTDIRB
+  mkdir $FONTDIRA
+  mkdir $CACHEDIR
+}
+
+dotest () {
+  TEST=$1
+  test x$VERBOSE = x || echo Running: $TEST
+}
+
+sed "s!@FONTDIR@!$FONTDIRA!
+s!@MAP@!!
+s!@CACHEDIR@!$CACHEDIR!" < $TESTDIR/fonts.conf.in > fonts-a.conf
+
+sed "s!@FONTDIR@!$FONTDIRB!
+s!@MAP@!map="'"'"$FONTDIRA"'"'"!
+s!@CACHEDIR@!$CACHEDIR!" < $TESTDIR/fonts.conf.in > fonts-b.conf
+
+sed "s!@FONTDIR@!$FONTDIRA!" < $EXPECTEDIN > $EXPECTEDA
+sed "s!@FONTDIR@!$FONTDIRB!" < $EXPECTEDIN > $EXPECTEDB
+
+FONTCONFIG_FILE="$MyPWD"/fonts-a.conf
+export FONTCONFIG_FILE
+
+dotest "Basic check"
+prep
+cp $FONT1 $FONT2 $FONTDIRA
+cp $EXPECTEDA $EXPECTED
+$FCCACHE $FONTDIRA
+check
+
+dotest "mapped check"
+prep
+cp $FONT1 $FONT2 $FONTDIRA
+cp $EXPECTEDB $EXPECTED
+$FCCACHE $FONTDIRA
+mv $FONTDIRA $FONTDIRB
+export FONTCONFIG_FILE="$MyPWD"/fonts-b.conf
+check
diff --git a/test/run-test.sh b/test/run-test.sh
index e76e39b..0f40ace 100644
--- a/test/run-test.sh
+++ b/test/run-test.sh
@@ -28,8 +28,9 @@ esac
 TESTDIR=${srcdir-"$MyPWD"}
 BUILDTESTDIR=${builddir-"$MyPWD"}
 
-FONTDIR="$MyPWD"/fonts
-CACHEDIR="$MyPWD"/cache.dir
+BASEDIR=`mktemp -d --tmpdir fontconfig.XXXXXXXX`
+FONTDIR="$BASEDIR"/fonts
+CACHEDIR="$BASEDIR"/cache.dir
 EXPECTED=${EXPECTED-"out.expected"}
 
 ECHO=true
@@ -72,6 +73,7 @@ dotest () {
 }
 
 sed "s!@FONTDIR@!$FONTDIR!
+s!@REMAPDIR@!!
 s!@CACHEDIR@!$CACHEDIR!" < $TESTDIR/fonts.conf.in > fonts.conf
 
 FONTCONFIG_FILE="$MyPWD"/fonts.conf
@@ -122,49 +124,6 @@ mkdir $FONTDIR/a
 cp $FONT2 $FONTDIR/a
 check
 
-dotest "Re-creating .uuid"
-prep
-cp $FONT1 $FONTDIR
-$FCCACHE $FONTDIR
-cat $FONTDIR/.uuid > out1
-$FCCACHE -f $FONTDIR
-cat $FONTDIR/.uuid > out2
-if cmp out1 out2 > /dev/null ; then : ; else
-  echo "*** Test failed: $TEST"
-  echo "*** .uuid was modified unexpectedly"
-  exit 1
-fi
-$FCCACHE -r $FONTDIR
-cat $FONTDIR/.uuid > out2
-if cmp out1 out2 > /dev/null ; then
-  echo "*** Test failed: $TEST"
-  echo "*** .uuid wasn't modified"
-  exit 1
-fi
-rm -f out1 out2
-
-dotest "Consistency between .uuid and cache name"
-prep
-cp $FONT1 $FONTDIR
-$FCCACHE $FONTDIR
-cat $FONTDIR/.uuid
-$FCCACHE -r $FONTDIR
-uuid=`cat $FONTDIR/.uuid`
-ls $CACHEDIR/$uuid*
-if [ $? != 0 ]; then
-  echo "*** Test failed: $TEST"
-  echo "No cache for $uuid"
-  ls $CACHEDIR
-  exit 1
-fi
-n=`ls -1 $CACHEDIR/*cache-* | wc -l`
-if [ $n != 1 ]; then
-  echo "*** Test failed: $TEST"
-  echo "Unexpected cache was created"
-  ls $CACHEDIR
-  exit 1
-fi
-
 dotest "Keep mtime of the font directory"
 prep
 cp $FONT1 $FONTDIR
@@ -178,7 +137,7 @@ if cmp out1 out2 > /dev/null ; then : ; else
     exit 1
 fi
 
-if [ x"$BWRAP" != "x" ]; then
+if [ x"$BWRAP" != "x" -a "x$EXEEXT" = "x" ]; then
 dotest "Basic functionality with the bind-mounted cache dir"
 prep
 cp $FONT1 $FONT2 $FONTDIR
@@ -187,6 +146,7 @@ sleep 1
 ls -l $CACHEDIR > out1
 TESTTMPDIR=`mktemp -d /tmp/fontconfig.XXXXXXXX`
 sed "s!@FONTDIR@!$TESTTMPDIR/fonts!
+s!@REMAPDIR@!<remap-dir as-path="'"'"$FONTDIR"'"'">$TESTTMPDIR/fonts</remap-dir>!
 s!@CACHEDIR@!$TESTTMPDIR/cache.dir!" < $TESTDIR/fonts.conf.in > bind-fonts.conf
 $BWRAP --bind / / --bind $CACHEDIR $TESTTMPDIR/cache.dir --bind $FONTDIR $TESTTMPDIR/fonts --bind .. $TESTTMPDIR/build --dev-bind /dev /dev --setenv FONTCONFIG_FILE $TESTTMPDIR/build/test/bind-fonts.conf $TESTTMPDIR/build/fc-match/fc-match$EXEEXT -f "%{file}\n" ":foundry=Misc" > xxx
 $BWRAP --bind / / --bind $CACHEDIR $TESTTMPDIR/cache.dir --bind $FONTDIR $TESTTMPDIR/fonts --bind .. $TESTTMPDIR/build --dev-bind /dev /dev --setenv FONTCONFIG_FILE $TESTTMPDIR/build/test/bind-fonts.conf $TESTTMPDIR/build/test/test-bz106618$EXEEXT | sort > flist1
@@ -194,7 +154,11 @@ $BWRAP --bind / / --bind $CACHEDIR $TESTTMPDIR/cache.dir --bind $FONTDIR $TESTTM
 ls -l $CACHEDIR > out2
 if cmp out1 out2 > /dev/null ; then : ; else
   echo "*** Test failed: $TEST"
-  echo "cache was updated."
+  echo "cache was created/updated."
+  echo "Before:"
+  cat out1
+  echo "After:"
+  cat out2
   exit 1
 fi
 if [ x`cat xxx` != "x$TESTTMPDIR/fonts/4x6.pcf" ]; then
@@ -212,46 +176,137 @@ if cmp flist1 flist2 > /dev/null ; then : ; else
   exit 1
 fi
 rm -rf $TESTTMPDIR out1 out2 xxx flist1 flist2 bind-fonts.conf
+
+dotest "Different directory content between host and sandbox"
+prep
+cp $FONT1 $FONTDIR
+$FCCACHE $FONTDIR
+sleep 1
+ls -1 --color=no $CACHEDIR/*cache*> out1
+stat -c '%n %s %y %z' `cat out1` > stat1
+TESTTMPDIR=`mktemp -d /tmp/fontconfig.XXXXXXXX`
+TESTTMP2DIR=`mktemp -d /tmp/fontconfig.XXXXXXXX`
+cp $FONT2 $TESTTMP2DIR
+sed "s!@FONTDIR@!$TESTTMPDIR/fonts</dir><dir salt="'"'"salt-to-make-different"'"'">$FONTDIR!
+s!@REMAPDIR@!<remap-dir as-path="'"'"$FONTDIR"'"'">$TESTTMPDIR/fonts</remap-dir>!
+s!@CACHEDIR@!$TESTTMPDIR/cache.dir!" < $TESTDIR/fonts.conf.in > bind-fonts.conf
+$BWRAP --bind / / --bind $CACHEDIR $TESTTMPDIR/cache.dir --bind $FONTDIR $TESTTMPDIR/fonts --bind $TESTTMP2DIR $FONTDIR --bind .. $TESTTMPDIR/build --dev-bind /dev /dev --setenv FONTCONFIG_FILE $TESTTMPDIR/build/test/bind-fonts.conf $TESTTMPDIR/build/fc-match/fc-match$EXEEXT -f "%{file}\n" ":foundry=Misc" > xxx
+$BWRAP --bind / / --bind $CACHEDIR $TESTTMPDIR/cache.dir --bind $FONTDIR $TESTTMPDIR/fonts --bind $TESTTMP2DIR $FONTDIR --bind .. $TESTTMPDIR/build --dev-bind /dev /dev --setenv FONTCONFIG_FILE $TESTTMPDIR/build/test/bind-fonts.conf $TESTTMPDIR/build/test/test-bz106618$EXEEXT | sort > flist1
+$BWRAP --bind / / --bind $CACHEDIR $TESTTMPDIR/cache.dir --bind $FONTDIR $TESTTMPDIR/fonts --bind $TESTTMP2DIR $FONTDIR --bind .. $TESTTMPDIR/build --dev-bind /dev /dev find $TESTTMPDIR/fonts/ -type f -name '*.pcf' | sort > flist2
+ls -1 --color=no $CACHEDIR/*cache* > out2
+stat -c '%n %s %y %z' `cat out1` > stat2
+if cmp stat1 stat2 > /dev/null ; then : ; else
+  echo "*** Test failed: $TEST"
+  echo "cache was created/updated."
+  cat stat1 stat2
+  exit 1
+fi
+if grep -v -- "`cat out1`" out2 > /dev/null ; then : ; else
+  echo "*** Test failed: $TEST"
+  echo "cache wasn't created for dir inside sandbox."
+  cat out1 out2
+  exit 1
+fi
+if [ x`cat xxx` != "x$TESTTMPDIR/fonts/4x6.pcf" ]; then
+  echo "*** Test failed: $TEST"
+  echo "file property doesn't point to the new place: $TESTTMPDIR/fonts/4x6.pcf"
+  exit 1
+fi
+if cmp flist1 flist2 > /dev/null ; then
+  echo "*** Test failed: $TEST"
+  echo "Missing fonts should be available on sandbox"
+  echo "Expected result:"
+  cat flist2
+  echo "Actual result:"
+  cat flist1
+  exit 1
 fi
+rm -rf $TESTTMPDIR $TESTTMP2DIR out1 out2 xxx flist1 flist2 stat1 stat2 bind-fonts.conf
 
+dotest "Check consistency of MD5 in cache name"
+prep
+mkdir -p $FONTDIR/sub
+cp $FONT1 $FONTDIR/sub
+$FCCACHE $FONTDIR
+sleep 1
+(cd $CACHEDIR; ls -1 --color=no *cache*) > out1
+TESTTMPDIR=`mktemp -d /tmp/fontconfig.XXXXXXXX`
+mkdir -p $TESTTMPDIR/cache.dir
+sed "s!@FONTDIR@!$TESTTMPDIR/fonts!
+s!@REMAPDIR@!<remap-dir as-path="'"'"$FONTDIR"'"'">$TESTTMPDIR/fonts</remap-dir>!
+s!@CACHEDIR@!$TESTTMPDIR/cache.dir!" < $TESTDIR/fonts.conf.in > bind-fonts.conf
+$BWRAP --bind / / --bind $FONTDIR $TESTTMPDIR/fonts --bind .. $TESTTMPDIR/build --dev-bind /dev /dev --setenv FONTCONFIG_FILE $TESTTMPDIR/build/test/bind-fonts.conf $TESTTMPDIR/build/fc-cache/fc-cache$EXEEXT $TESTTMPDIR/fonts
+(cd $TESTTMPDIR/cache.dir; ls -1 --color=no *cache*) > out2
+if cmp out1 out2 > /dev/null ; then : ; else
+    echo "*** Test failed: $TEST"
+    echo "cache was created unexpectedly."
+    echo "Before:"
+    cat out1
+    echo "After:"
+    cat out2
+    exit 1
+fi
+rm -rf $TESTTMPDIR out1 out2 bind-fonts.conf
+
+dotest "Fallback to uuid"
+prep
+cp $FONT1 $FONTDIR
+touch -d @`stat -c %Y $FONTDIR` $FONTDIR
+$FCCACHE $FONTDIR
+sleep 1
+_cache=`ls -1 --color=no $CACHEDIR/*cache*`
+_mtime=`stat -c %Y $FONTDIR`
+_uuid=`uuidgen`
+_newcache=`echo $_cache | sed "s/\([0-9a-f]*\)\(\-.*\)/$_uuid\2/"`
+mv $_cache $_newcache
+echo $_uuid > $FONTDIR/.uuid
+touch -d @$_mtime $FONTDIR
+(cd $CACHEDIR; ls -1 --color=no *cache*) > out1
+TESTTMPDIR=`mktemp -d /tmp/fontconfig.XXXXXXXX`
+mkdir -p $TESTTMPDIR/cache.dir
+sed "s!@FONTDIR@!$TESTTMPDIR/fonts!
+s!@REMAPDIR@!<remap-dir as-path="'"'"$FONTDIR"'"'">$TESTTMPDIR/fonts</remap-dir>!
+s!@CACHEDIR@!$TESTTMPDIR/cache.dir!" < $TESTDIR/fonts.conf.in > bind-fonts.conf
+$BWRAP --bind / / --bind $CACHEDIR $TESTTMPDIR/cache.dir --bind $FONTDIR $TESTTMPDIR/fonts --bind .. $TESTTMPDIR/build --dev-bind /dev /dev --setenv FONTCONFIG_FILE $TESTTMPDIR/build/test/bind-fonts.conf $TESTTMPDIR/build/fc-match/fc-match$EXEEXT -f ""
+(cd $CACHEDIR; ls -1 --color=no *cache*) > out2
+if cmp out1 out2 > /dev/null ; then : ; else
+    echo "*** Test failed: $TEST"
+    echo "cache was created unexpectedly."
+    echo "Before:"
+    cat out1
+    echo "After:"
+    cat out2
+    exit 1
+fi
+rm -rf $TESTTMPDIR out1 out2 bind-fonts.conf
+
+else
+    echo "No bubblewrap installed. skipping..."
+fi # if [ x"$BWRAP" != "x" -a "x$EXEEXT" = "x" ]
+
+if [ "x$EXEEXT" = "x" ]; then
 dotest "sysroot option"
 prep
 mkdir -p $MyPWD/sysroot/$FONTDIR
 mkdir -p $MyPWD/sysroot/$CACHEDIR
+mkdir -p $MyPWD/sysroot/$MyPWD
 cp $FONT1 $MyPWD/sysroot/$FONTDIR
 cp $MyPWD/fonts.conf $MyPWD/sysroot/$MyPWD/fonts.conf
 $FCCACHE -y $MyPWD/sysroot
-stat $MyPWD/sysroot/$FONTDIR/.uuid
-if test $? != 0; then
-  echo "*** Test failed: $TEST"
-  exit 1
-fi
 
-dotest "creating uuid-based cache file on sysroot"
-uuid=`cat $MyPWD/sysroot/$FONTDIR/.uuid`
-ls $MyPWD/sysroot/$CACHEDIR/$uuid*
+dotest "creating cache file on sysroot"
+md5=`echo -n $FONTDIR | md5sum | sed 's/ .*$//'`
+echo "checking for cache file $md5"
+ls "$MyPWD/sysroot/$CACHEDIR/$md5"*
 if [ $? != 0 ]; then
   echo "*** Test failed: $TEST"
-  echo "No cache for $uuid"
+  echo "No cache for $FONTDIR ($md5)"
   ls $MyPWD/sysroot/$CACHEDIR
   exit 1
 fi
 
 rm -rf $MyPWD/sysroot
 
-dotest "deleting .uuid file on empty dir"
-prep
-cp $FONT1 $FONT2 $FONTDIR
-$FCCACHE $FONTDIR
-sleep 1
-rm -f $FONTDIR/*pcf
-$FCCACHE $FONTDIR
-rmdir $FONTDIR > /dev/null 2>&1
-if [ $? != 0 ]; then
-  echo "*** Test failed: $TEST"
-  echo "$FONTDIR isn't empty"
-  ls -al $FONTDIR
-  exit 1
-fi
+fi # if [ "x$EXEEXT" = "x" ]
 
-rm -rf $FONTDIR $CACHEFILE $CACHEDIR $FONTCONFIG_FILE out
+rm -rf $FONTDIR $CACHEFILE $CACHEDIR $BASEDIR $FONTCONFIG_FILE out
diff --git a/test/test-bz106632.c b/test/test-bz106632.c
index daa0c1e..5a1e256 100644
--- a/test/test-bz106632.c
+++ b/test/test-bz106632.c
@@ -25,25 +25,26 @@
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
+#include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include <dirent.h>
+#include <unistd.h>
+#include <errno.h>
 #ifndef HAVE_STRUCT_DIRENT_D_TYPE
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <unistd.h>
 #endif
-#include "fcstr.c"
-#undef FcConfigBuildFonts
-#undef FcConfigCreate
-#undef FcConfigGetCurrent
-#undef FcConfigParseAndLoadFromMemory
-#undef FcConfigUptoDate
-#undef FcFontList
-#undef FcInitReinitialize
-#undef FcPatternCreate
-#undef FcPatternDestroy
 #include <fontconfig/fontconfig.h>
 
+#ifdef _WIN32
+#  define FC_DIR_SEPARATOR         '\\'
+#  define FC_DIR_SEPARATOR_S       "\\"
+#else
+#  define FC_DIR_SEPARATOR         '/'
+#  define FC_DIR_SEPARATOR_S       "/"
+#endif
+
 #ifdef HAVE_MKDTEMP
 #define fc_mkdtemp	mkdtemp
 #else
@@ -154,26 +155,14 @@ unlink_dirs (const char *dir)
     return ret;
 }
 
-FcChar8 *
-FcLangNormalize (const FcChar8 *lang)
-{
-    return NULL;
-}
-
-FcChar8 *
-FcConfigHome (void)
-{
-    return NULL;
-}
-
 int
 main (void)
 {
-    FcChar8 *fontdir = NULL, *cachedir = NULL, *fontname;
+    FcChar8 *fontdir = NULL, *cachedir = NULL;
     char *basedir, template[512] = "/tmp/bz106632-XXXXXX";
     char cmd[512];
     FcConfig *config;
-    const FcChar8 *tconf = "<fontconfig>\n"
+    const FcChar8 *tconf = (const FcChar8 *) "<fontconfig>\n"
 	"  <dir>%s</dir>\n"
 	"  <cachedir>%s</cachedir>\n"
 	"</fontconfig>\n";
@@ -189,21 +178,21 @@ main (void)
 	fprintf (stderr, "%s: %s\n", template, strerror (errno));
 	goto bail;
     }
-    fontdir = FcStrBuildFilename (basedir, "fonts", NULL);
-    cachedir = FcStrBuildFilename (basedir, "cache", NULL);
+    fontdir = FcStrBuildFilename ((const FcChar8 *) basedir, (const FcChar8 *) "fonts", NULL);
+    cachedir = FcStrBuildFilename ((const FcChar8 *) basedir, (const FcChar8 *) "cache", NULL);
     fprintf (stderr, "D: Creating %s\n", fontdir);
-    mkdir_p (fontdir);
+    mkdir_p ((const char *) fontdir);
     fprintf (stderr, "D: Creating %s\n", cachedir);
-    mkdir_p (cachedir);
+    mkdir_p ((const char *) cachedir);
 
     fprintf (stderr, "D: Copying %s to %s\n", FONTFILE, fontdir);
-    snprintf (cmd, 512, "cp -a %s %s", FONTFILE, fontdir);
-    system (cmd);
+    snprintf (cmd, 512, "sleep 1; cp -a %s %s; sleep 1", FONTFILE, fontdir);
+    (void) system (cmd);
 
     fprintf (stderr, "D: Loading a config\n");
-    snprintf (conf, 1024, tconf, fontdir, cachedir);
+    snprintf (conf, 1024, (const char *) tconf, fontdir, cachedir);
     config = FcConfigCreate ();
-    if (!FcConfigParseAndLoadFromMemory (config, conf, FcTrue))
+    if (!FcConfigParseAndLoadFromMemory (config, (const FcChar8 *) conf, FcTrue))
     {
 	printf ("E: Unable to load config\n");
 	ret = 1;
@@ -226,15 +215,21 @@ main (void)
 	goto bail;
     }
     fprintf (stderr, "D: Removing %s\n", fontdir);
-    snprintf (cmd, 512, "rm -f %s%s*", fontdir, FC_DIR_SEPARATOR_S);
-    system (cmd);
+    snprintf (cmd, 512, "sleep 1; rm -f %s%s*; sleep 1", fontdir, FC_DIR_SEPARATOR_S);
+    (void) system (cmd);
     fprintf (stderr, "D: Reinitializing\n");
-    if (!FcConfigUptoDate (config) || !FcInitReinitialize ())
+    if (FcConfigUptoDate(config))
     {
-	fprintf (stderr, "E: Unable to reinitialize\n");
+	fprintf (stderr, "E: Config reports up-to-date\n");
 	ret = 2;
 	goto bail;
     }
+    if (!FcInitReinitialize ())
+    {
+	fprintf (stderr, "E: Unable to reinitialize\n");
+	ret = 3;
+	goto bail;
+    }
     if (FcConfigGetCurrent () == config)
     {
 	fprintf (stderr, "E: config wasn't reloaded\n");
@@ -242,7 +237,7 @@ main (void)
 	goto bail;
     }
     config = FcConfigCreate ();
-    if (!FcConfigParseAndLoadFromMemory (config, conf, FcTrue))
+    if (!FcConfigParseAndLoadFromMemory (config, (const FcChar8 *) conf, FcTrue))
     {
 	printf ("E: Unable to load config again\n");
 	ret = 4;
@@ -265,10 +260,16 @@ main (void)
 	goto bail;
     }
     fprintf (stderr, "D: Copying %s to %s\n", FONTFILE, fontdir);
-    snprintf (cmd, 512, "cp -a %s %s", FONTFILE, fontdir);
-    system (cmd);
+    snprintf (cmd, 512, "sleep 1; cp -a %s %s; sleep 1", FONTFILE, fontdir);
+    (void) system (cmd);
     fprintf (stderr, "D: Reinitializing\n");
-    if (!FcConfigUptoDate (config) || !FcInitReinitialize ())
+    if (FcConfigUptoDate(config))
+    {
+	fprintf (stderr, "E: Config up-to-date after addition\n");
+	ret = 3;
+	goto bail;
+    }
+    if (!FcInitReinitialize ())
     {
 	fprintf (stderr, "E: Unable to reinitialize\n");
 	ret = 2;
@@ -281,7 +282,7 @@ main (void)
 	goto bail;
     }
     config = FcConfigCreate ();
-    if (!FcConfigParseAndLoadFromMemory (config, conf, FcTrue))
+    if (!FcConfigParseAndLoadFromMemory (config, (const FcChar8 *) conf, FcTrue))
     {
 	printf ("E: Unable to load config again\n");
 	ret = 4;
diff --git a/test/test-conf.c b/test/test-conf.c
index 6619ea7..37a4300 100644
--- a/test/test-conf.c
+++ b/test/test-conf.c
@@ -29,6 +29,7 @@
 
 struct _FcConfig {
     FcStrSet	*configDirs;	    /* directories to scan for fonts */
+    FcStrSet    *configMapDirs;
     FcStrSet	*fontDirs;
     FcStrSet	*cacheDirs;
     FcStrSet	*configFiles;	    /* config files loaded */
diff --git a/test/test-hash.c b/test/test-hash.c
deleted file mode 100644
index 7530e82..0000000
--- a/test/test-hash.c
+++ /dev/null
@@ -1,187 +0,0 @@
-#include "../src/fchash.c"
-#include "../src/fcstr.c"
-
-FcChar8 *
-FcLangNormalize (const FcChar8 *lang)
-{
-    return NULL;
-}
-
-FcChar8 *
-FcConfigHome (void)
-{
-    return NULL;
-}
-
-typedef struct _Test
-{
-    FcHashTable *table;
-} Test;
-
-static Test *
-init (void)
-{
-    Test *ret;
-
-    ret = malloc (sizeof (Test));
-    if (ret)
-    {
-	ret->table = FcHashTableCreate ((FcHashFunc) FcStrHashIgnoreCase,
-					(FcCompareFunc) FcStrCmp,
-					FcHashStrCopy,
-					FcHashUuidCopy,
-					(FcDestroyFunc) FcStrFree,
-					FcHashUuidFree);
-    }
-
-    return ret;
-}
-
-static void
-fini (Test *test)
-{
-    FcHashTableDestroy (test->table);
-    free (test);
-}
-
-static FcBool
-test_add (Test *test, FcChar8 *key, FcBool replace)
-{
-    uuid_t uuid;
-    void *u;
-    FcBool (*hash_add) (FcHashTable *, void *, void *);
-    FcBool ret = FcFalse;
-
-    uuid_generate_random (uuid);
-    if (replace)
-	hash_add = FcHashTableReplace;
-    else
-	hash_add = FcHashTableAdd;
-    if (!hash_add (test->table, key, uuid))
-	return FcFalse;
-    if (!FcHashTableFind (test->table, key, &u))
-	return FcFalse;
-    ret = (uuid_compare (uuid, u) == 0);
-    FcHashUuidFree (u);
-
-    return ret;
-}
-
-static FcBool
-test_remove (Test *test, FcChar8 *key)
-{
-    void *u;
-
-    if (!FcHashTableFind (test->table, key, &u))
-	return FcFalse;
-    FcHashUuidFree (u);
-    if (!FcHashTableRemove (test->table, key))
-	return FcFalse;
-    if (FcHashTableFind (test->table, key, &u))
-	return FcFalse;
-
-    return FcTrue;
-}
-
-int
-main (void)
-{
-    Test *test;
-    uuid_t uuid;
-    int ret = 0;
-
-    test = init ();
-    /* first op to add */
-    if (!test_add (test, "foo", FcFalse))
-    {
-	ret = 1;
-	goto bail;
-    }
-    /* second op to add */
-    if (!test_add (test, "bar", FcFalse))
-    {
-	ret = 1;
-	goto bail;
-    }
-    /* dup not allowed */
-    if (test_add (test, "foo", FcFalse))
-    {
-	ret = 1;
-	goto bail;
-    }
-    /* replacement */
-    if (!test_add (test, "foo", FcTrue))
-    {
-	ret = 1;
-	goto bail;
-    }
-    /* removal */
-    if (!test_remove (test, "foo"))
-    {
-	ret = 1;
-	goto bail;
-    }
-    /* not found to remove */
-    if (test_remove (test, "foo"))
-    {
-	ret = 1;
-	goto bail;
-    }
-    /* complex op in pointer */
-    if (!test_add (test, "foo", FcFalse))
-    {
-	ret = 1;
-	goto bail;
-    }
-    if (test_add (test, "foo", FcFalse))
-    {
-	ret = 1;
-	goto bail;
-    }
-    if (!test_remove (test, "foo"))
-    {
-	ret = 1;
-	goto bail;
-    }
-    if (!test_add (test, "foo", FcFalse))
-    {
-	ret = 1;
-	goto bail;
-    }
-    if (!test_remove (test, "bar"))
-    {
-	ret = 1;
-	goto bail;
-    }
-    /* completely remove */
-    if (!test_remove (test, "foo"))
-    {
-	ret = 1;
-	goto bail;
-    }
-    /* completely remove from the last one */
-    if (!test_add (test, "foo", FcFalse))
-    {
-	ret = 1;
-	goto bail;
-    }
-    if (!test_add (test, "bar", FcFalse))
-    {
-	ret = 1;
-	goto bail;
-    }
-    if (!test_remove (test, "bar"))
-    {
-	ret = 1;
-	goto bail;
-    }
-    if (!test_remove (test, "foo"))
-    {
-	ret = 1;
-	goto bail;
-    }
-bail:
-    fini (test);
-
-    return ret;
-}
diff --git a/test/test-issue107.c b/test/test-issue107.c
new file mode 100644
index 0000000..7f4bfb0
--- /dev/null
+++ b/test/test-issue107.c
@@ -0,0 +1,248 @@
+/*
+ * fontconfig/test/test-issue107.c
+ *
+ * Copyright Â© 2000 Keith Packard
+ * Copyright Â© 2018 Akira TAGOH
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the author(s) not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  The authors make no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * THE AUTHOR(S) DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <errno.h>
+#ifndef HAVE_STRUCT_DIRENT_D_TYPE
+#include <sys/types.h>
+#include <sys/stat.h>
+#endif
+#include <fontconfig/fontconfig.h>
+
+#ifdef _WIN32
+#  define FC_DIR_SEPARATOR         '\\'
+#  define FC_DIR_SEPARATOR_S       "\\"
+#else
+#  define FC_DIR_SEPARATOR         '/'
+#  define FC_DIR_SEPARATOR_S       "/"
+#endif
+
+extern FcChar8 *FcConfigRealFilename (FcConfig *, FcChar8 *);
+
+#ifdef HAVE_MKDTEMP
+#define fc_mkdtemp	mkdtemp
+#else
+char *
+fc_mkdtemp (char *template)
+{
+    if (!mktemp (template) || mkdir (template, 0700))
+	return NULL;
+
+    return template;
+}
+#endif
+
+FcBool
+mkdir_p (const char *dir)
+{
+    char *parent;
+    FcBool ret;
+
+    if (strlen (dir) == 0)
+	return FcFalse;
+    parent = (char *) FcStrDirname ((const FcChar8 *) dir);
+    if (!parent)
+	return FcFalse;
+    if (access (parent, F_OK) == 0)
+	ret = mkdir (dir, 0755) == 0 && chmod (dir, 0755) == 0;
+    else if (access (parent, F_OK) == -1)
+	ret = mkdir_p (parent) && (mkdir (dir, 0755) == 0) && chmod (dir, 0755) == 0;
+    else
+	ret = FcFalse;
+    free (parent);
+
+    return ret;
+}
+
+FcBool
+unlink_dirs (const char *dir)
+{
+    DIR *d = opendir (dir);
+    struct dirent *e;
+    size_t len = strlen (dir);
+    char *n = NULL;
+    FcBool ret = FcTrue;
+#ifndef HAVE_STRUCT_DIRENT_D_TYPE
+    struct stat statb;
+#endif
+
+    if (!d)
+	return FcFalse;
+    while ((e = readdir (d)) != NULL)
+    {
+	size_t l;
+
+	if (strcmp (e->d_name, ".") == 0 ||
+	    strcmp (e->d_name, "..") == 0)
+	    continue;
+	l = strlen (e->d_name) + 1;
+	if (n)
+	    free (n);
+	n = malloc (l + len + 1);
+	if (!n)
+	{
+	    ret = FcFalse;
+	    break;
+	}
+	strcpy (n, dir);
+	n[len] = FC_DIR_SEPARATOR;
+	strcpy (&n[len + 1], e->d_name);
+#ifdef HAVE_STRUCT_DIRENT_D_TYPE
+	if (e->d_type == DT_DIR)
+#else
+	if (stat (n, &statb) == -1)
+	{
+	    fprintf (stderr, "E: %s\n", n);
+	    ret = FcFalse;
+	    break;
+	}
+	if (S_ISDIR (statb.st_mode))
+#endif
+	{
+	    if (!unlink_dirs (n))
+	    {
+		fprintf (stderr, "E: %s\n", n);
+		ret = FcFalse;
+		break;
+	    }
+	}
+	else
+	{
+	    if (unlink (n) == -1)
+	    {
+		fprintf (stderr, "E: %s\n", n);
+		ret = FcFalse;
+		break;
+	    }
+	}
+    }
+    if (n)
+	free (n);
+    closedir (d);
+
+    if (rmdir (dir) == -1)
+    {
+	fprintf (stderr, "E: %s\n", dir);
+	return FcFalse;
+    }
+
+    return ret;
+}
+
+int
+main(void)
+{
+    FcConfig *cfg = FcConfigCreate ();
+    char *basedir, template[512] = "/tmp/fc107-XXXXXX";
+    char *sysroot, systempl[512] = "/tmp/fc107-XXXXXX";
+    FcChar8 *d = NULL, *dd = NULL;
+    FcCache *c = NULL;
+    const FcChar8 *doc = ""
+	"<fontconfig>\n"
+	"  <dir>%s</dir>\n"
+	"</fontconfig>\n"
+	"";
+    int retval = 0;
+    size_t len;
+
+    retval++;
+    basedir = fc_mkdtemp (template);
+    if (!basedir)
+    {
+	fprintf (stderr, "%s: %s\n", template, strerror (errno));
+	goto bail;
+    }
+    retval++;
+    sysroot = fc_mkdtemp (systempl);
+    if (!sysroot)
+    {
+	fprintf (stderr, "%s: %s\n", systempl, strerror (errno));
+	goto bail;
+    }
+    retval++;
+    fprintf (stderr, "D: Creating %s\n", basedir);
+    mkdir_p (basedir);
+    len = strlen (doc) + strlen (basedir) + 1;
+    dd = malloc (len);
+    snprintf (dd, len, doc, basedir);
+    if (!FcConfigParseAndLoadFromMemory (cfg, dd, FcFalse))
+    {
+	fprintf (stderr, "%s: Unable to load a config\n", basedir);
+	goto bail;
+    }
+    sleep (1);
+    c = FcDirCacheRead (basedir, FcFalse, cfg);
+    FcDirCacheUnload (c);
+    sleep (1);
+    retval++;
+    if (!FcConfigUptoDate (cfg))
+    {
+	fprintf (stderr, "updated. need to reload.\n");
+	goto bail;
+    }
+    setenv ("FONTCONFIG_SYSROOT", sysroot, 1);
+    fprintf (stderr, "D: Creating %s\n", sysroot);
+    mkdir_p (sysroot);
+    retval++;
+    d = FcStrBuildFilename (sysroot, basedir, NULL);
+    fprintf (stderr, "D: Creating %s\n", d);
+    mkdir_p (d);
+    free (d);
+    retval++;
+    free (dd);
+    len = strlen (doc) + strlen (basedir) + 1;
+    dd = malloc (len);
+    snprintf (dd, len, doc, basedir);
+    if (!FcConfigParseAndLoadFromMemory (cfg, dd, FcFalse))
+    {
+	fprintf (stderr, "%s: Unable to load a config\n", basedir);
+	goto bail;
+    }
+    sleep (1);
+    c = FcDirCacheRead (basedir, FcFalse, cfg);
+    FcDirCacheUnload (c);
+    sleep (1);
+    retval++;
+    if (!FcConfigUptoDate (cfg))
+    {
+	fprintf (stderr, "updated. need to reload (sysroot)\n");
+	goto bail;
+    }
+    retval = 0;
+bail:
+    fprintf (stderr, "Cleaning up\n");
+    unlink_dirs (basedir);
+    if (dd)
+	free (dd);
+    FcConfigDestroy (cfg);
+
+    return retval;
+}
